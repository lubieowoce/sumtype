from typing import (
	Any,
	Tuple, List, Iterator,
	Callable,
	TypeVar,
	NoReturn, # functions that always raise or exit the interpreter 
)

from indented.text    import flatten_tree
from indented.codegen import (
	lit, apply, 
	tuple_, dict_,
	def_, cond, when,
	join_with_op,
	eval_def,
)

Fun = Callable
A = TypeVar('A')

import sys
from warnings import warn

from keyword import iskeyword


__all__ = [
	'sumtype',
	'untyped_sumtype',
]




def sumtype(
		name: str,
		variant_specs: List[  Tuple[str, List[Tuple[str, type]] ]  ],
		*,
		typecheck=False,
		immutable=True,
		verbose=False,
		allow_zero_constructors=False,
		_module_name=None,
		_set_members_with_assignment=False
	) -> type:

	if typecheck:
		raise NotImplementedError('Typechecking is not supported yet')
	if not immutable:
		raise NotImplementedError('Mutability is not supported yet')
	
	if verbose: print('sumtype::', name, *variant_specs, sep='\n')
	variant_specs = [(variant_name, [attr_name for (attr_name, attr_type) in attr_names_and_types])
					 for (variant_name, attr_names_and_types) in variant_specs]

	# module name

	# `untyped_sumtype` relies on sys._getframe to inspect the caller's frame and
	# get the right module name. That won't work if `sumtype` calls it,
	# since the caller's frame will be located in this module.
	# So we have to get the module name here, and pass it down.				 
	if _module_name is None:
		try:
			_module_name = sys._getframe(1).f_globals.get('__name__', '__main__')
		except (AttributeError, ValueError):
			warn(RuntimeWarning("Cannot access the caller's module name - pickle will likely have trouble unpickling {} objects".format(name)))
			_module_name = '<generated by sumtype>'

	return \
		untyped_sumtype(
			name,
			variant_specs,
			immutable=immutable,
			verbose=verbose,
			allow_zero_constructors=allow_zero_constructors,
			_module_name=_module_name,
			_set_members_with_assignment=_set_members_with_assignment
		) 




def untyped_sumtype(
		name: str,
		variant_specs: List[ Tuple[str, List[str]] ],
		*,
		immutable=True,
		verbose=False,
		allow_zero_constructors=False,
		_module_name=None,
		_set_members_with_assignment=False
	) -> type:

	if not allow_zero_constructors and not variant_specs:
		raise ValueError('No variants specified - probably a bug. Pass `allow_zero_constructors=False` to allow this.')
		
	if (_set_members_with_assignment and immutable):
		raise ValueError('Cannot use assignment to set members if the class is immutable')
	# if not immutable:
	# 	raise NotImplementedError('Mutability is not supported yet')

	variant_names      = [variant_name for (variant_name, attr_names_and_types) in variant_specs]
	variant_attr_names = [attr_names for (variant_name, attr_names) in variant_specs]
	variant_ids = range(len(variant_names))

	# # useful for the typed version:
	# variant_attr_specs = [attr_names_and_types for (variant_name, attr_names_and_types) in variant_specs]
	# variant_attr_names = [[attr_name for (attr_name, attr_type) in attr_names_and_types] for attr_names_and_types in variant_attr_specs]
	# # variant_attr_types = [[attr_type for (attr_name, attr_type) in attr_names_and_types] for attr_names_and_types in variant_attr_specs]

	max_n_fields = max((len(attrs) for attrs in variant_attr_names), default=0)
	slots = ('_variant_id',) + tuple('_{}'.format(i) for i in range(max_n_fields))
	if verbose:
		print('class {}:'.format(name))
		print('__slots__ =', slots, end='\n\n')
		print('...', end='\n\n')



	class Class:
		__slots__ = slots
		_variants    = variant_names
		_variant_ids = tuple(variant_ids)
		_variant_fields = {
			name: tuple(fields)
			for (name, fields) in zip(variant_names, variant_attr_names)
		}
		_variant_id_fields = tuple(tuple(field_names) for field_names in variant_attr_names)

		ARGUMENT_UNUSED = object() # used to test if a keyword argument was passed or not


		def raise_direct_init_forbidden(self) -> NoReturn:
			""" Objects of this class can only be created with its constructor-classmethods. """
			cls = self.__class__
			raise TypeError(
				'Cannot instantiate {type!r} directly - use one of the variant constructors: {vars}'.format(
					type=cls.__name__, vars=cls._variants_repr()
				)
			)
		__init__ = raise_direct_init_forbidden


		@property
		def _variant(self) -> str:
			return self.__class__._variants[self._variant_id]
		variant = _variant


		# def _values(self) -> tuple:
		# 	# TODO: codegen it
		# 	cls = self.__class__
		# 	field_vals = (
		# 		field_descriptor.__get__(self)
		# 		for field_descriptor
		# 		in cls._positional_descriptors[ : len(cls._variant_id_fields[self._variant_id])]
		# 	)
		# 	return tuple(field_vals)
		# values = _values


		# def _as_tuple(self) -> tuple:
		# 	return (self._variant,) + self._values()
		# as_tuple = _as_tuple 
		# _astuple = _as_tuple # namedtuple convention
		# astuple  = _as_tuple



		# def _as_dict(self) -> dict:
		# 	# TODO: codegen it
		# 	cls = self.__class__
		# 	res = {'variant': self._variant}
		# 	for (field, val) in zip(cls._variant_id_fields[self._variant_id], self._values()):
		# 		res[field] = val
		# 	return res
		# as_dict = _as_dict
		# _asdict = _as_dict # namedtuple convention
		# asdict  = _as_dict # namedtuple convention



		# def _replace(self, **fields_and_new_vals) -> name:
		# 	"""
		# 	Analogous to `namedtuple`'s `_replace`.
		# 	Returns a new value with fields modified according
		# 	to the keyword arguments.
		# 	"""
		# 	cls = self.__class__
		# 	fields = cls._variant_id_fields[self._variant_id]
		# 	field_descriptors = cls._positional_descriptors

		# 	new = cls.__new__(cls)
		# 	variant_id_descriptor = cls._variant_id
		# 	variant_id_descriptor.__set__(new, self._variant_id)

		# 	# important - by using zip, `field_descriptors` gets trimmed to the length of `fields`,
		# 	# so we never access an uninitialized attribute
		# 	for (field, field_descriptor) in zip(fields, field_descriptors):
		# 		old_field_val = field_descriptor.__get__(self)
		# 		new_field_val = fields_and_new_vals.pop(field, old_field_val)
		# 		field_descriptor.__set__(new, new_field_val)

		# 	if not fields_and_new_vals:
		# 		return new
		# 	else:
		# 		# Reuse __getattr__'s error cause guessing.
		# 		# TODO: Factor it out to make it less hacky.
		# 		first_bad_field = next(iter(fields_and_new_vals))
		# 		if first_bad_field.startswith('_'):
		# 			# Catch this here. if __getattr__ sees this name, 
		# 			# it will (correctly) guess that it can't be a field,
		# 			# and will show the generic "object doesn't have attribute x" error.
		# 			# However, if someone tries to `a._replace(_variant_id=15)`, the message will
		# 			# be confusing, because the objects clearly *do* have a '_variant_id' attribute. 
		# 			raise TypeError("_replace can only modify fields, and '{}' is not a field".format(first_bad_field))
		# 		else:
		# 			# getattr should give a nice error message
		# 			self.__getattr__(first_bad_field)
		#
		#
		# replace = _replace
		# set     = _replace
		# update  = _replace

		@classmethod
		def _from_tuple(cls, tup: tuple) -> name:
			new = cls.__new__(cls)
			new.__setstate__(tup)
			return new


		def __hash__(self):
			return hash(self._as_tuple())


		def _copy(self) -> name:
			""" Returns a shallow copy of self. """
			# TODO: efficiency - codegen it
			cls = self.__class__

			new = cls.__new__(cls)
			variant_id_descriptor = cls._variant_id
			variant_id_descriptor.__set__(new, self._variant_id)

			for field_descriptor in cls._positional_descriptors[ : len(cls._variant_id_fields[self._variant_id])]:
				field_val = field_descriptor.__get__(self)
				field_descriptor.__set__(new, field_val)
			return new

		copy = _copy
		

		# Pickle methods
		# 	We used __getstate__ and __setstate__ instead of __getnewargs__
		#	because even after calling __new__ the correct arguments,
		#	pickle tried to manually set each attribute from __slots__,
		#	which didn't work because __setattr__ blocks all modification attempts.
		#	__(get/set)state__ make pickle back off and let us handle all initialization. 

		def __getstate__(self) -> tuple:
			""" For pickling """
			return self._as_tuple()

		# def __setstate__(self, state: tuple) -> None:
		# 	""" For unpickling """
		# 	# TODO: efficiency - codegen it
		# 	cls = self.__class__
		# 	_variant_id, *field_vals = state

		# 	variant_id_descriptor = cls._variant_id
		# 	variant_id_descriptor.__set__(self, _variant_id)

		# 	field_descriptors = cls._positional_descriptors 
		# 	for (field_descriptor, field_val) in zip(field_descriptors, field_vals):
		# 		field_descriptor.__set__(self, field_val)




		# Methods that always raise

		def impossible(self) -> NoReturn:
			raise self.__class__._get_invalid_variant_error(self._variant_id)

		def _raise_error_missing_descriptor(self, attr: str) -> NoReturn:
			"""
			A fake __getattr__ implemented only to give better error messages.
			Will always raise an exception, because if it was called, one of the
			following is true:
			- the class has no data descriptor for `attr`
			- the class has a data descriptor for `attr`, but the descriptor raised AttributeError()
				(e.g. the user tried to access an uninitialized slot)
			"""

			cls = self.__class__

			if cls._is_unsafe_accessor_name(attr):
				attr = cls._extract_field_from_unsafe_accessor_name(attr)

			ex = None
			if any(attr in fields for fields in cls._variant_fields.values()):
				# A data descriptor for 'attr' exists, but it raised AttributeError() and the interpreter called __getattr__ as a fallback
				ex = AttributeError(
					"Incorrect '{type}' variant: Field '{attr}' not declared in variant '{var}'. Variants: {vars}".format(
						attr=attr, var=self._variant, type=cls.__qualname__, vars=cls._variants_repr(),
					),
				)
			elif cls._is_permitted_sumtype_field_name(attr):
				# No data descriptor for 'attr' exists - if we didn't create it, then there's no attribute with
				# this name in any variant
				ex = AttributeError(
					"Unknown attribute: Field '{attr}' not declared in any variant of '{type}': {vars}".format(
						attr=attr, type=cls.__qualname__, vars=cls._variants_repr(),
					) 
				)
			else: # Couldn't possibly be a field - probably a typo or nonexistent method
				ex = AttributeError("'{type}' object has no attribute '{attr}'".format(type=cls.__qualname__, attr=attr,) )

			raise ex
		__getattr__ = _raise_error_missing_descriptor



		if immutable:
			def _raise_setattr_forbidden(self, attr: str, val) -> NoReturn:
				"""
				A fake __setattr__ implemented only to give better error messages
				for attribute modification attempts.
				"""
				raise TypeError(
					"Cannot modify '{type}' values. Use `myval2 = myval.replace(attr=x)` instead. (Tried to set {self}.{field} = {val!r})".format(
						type=self.__class__.__qualname__, self=self, field=attr, val=val,
					)
				)
			__setattr__ = _raise_setattr_forbidden



		def _raise_delattr_forbidden(self, attr: str) -> NoReturn:
			"""
			A fake __delattr__ implemented only to give better error messages
			for attribute modification attempts.
			"""
			raise TypeError(
				"Cannot modify '{type}' values.".format(
					type=self.__class__.__qualname__,
				)
			)
		__delattr__ = _raise_delattr_forbidden

		
		@classmethod
		def _variant_reprs(cls) -> Iterator[str]:
			return (
				"{var}({fields})".format(var=variant, fields=str.join(', ', cls._variant_fields[variant]))
				for variant in cls._variants
			)


		# Error message helpers

		@classmethod
		def _variants_repr(cls) -> str:
			"Used to display all the variants in error messages."
			return str.join(', ', cls._variant_reprs())

		@classmethod
		def _is_permitted_sumtype_field_name(cls, field: str) -> bool:
			return not field.startswith('_') and not iskeyword(field)


		@classmethod
		def _is_unsafe_accessor_name(cls, field: str) -> bool:
			""" '_Foo_x' -> True """
			return any(field.startswith('_{}_'.format(variant)) for variant in cls._variants)

		@classmethod
		def _extract_field_from_unsafe_accessor_name(cls, field: str) -> str:
			return field.split('_', maxsplit=2)[2]

		@classmethod
		def _get_invalid_variant_error(cls, variant_id) -> Exception:
			return RuntimeError(
				"Internal error: {id} is not a valid '{type}' variant id  (ids: {ids})".format(
					type=cls.__qualname__, id=variant_id, ids=cls._variant_ids,
				)
			)
			

	# end class


	# class name
	Class.__name__     = name
	Class.__qualname__ = name

	if _module_name is None:
		# caller of `sumtype` didn't pass a module name - get the caller's module name
		try:
			_module_name = sys._getframe(1).f_globals.get('__name__', '__main__')
		except (AttributeError, ValueError):
			warn(
				RuntimeWarning(
					"`untyped_sumtype` can't access the caller's module name - pickle will likely have trouble unpickling {!r} objects".format(name)
				)
			)
			_module_name = '<generated by sumtype>'
	Class.__module__ = _module_name

	variant_def_indent = ' ' * (len(name) + 1)
	Class.__doc__ = (
		'A sum type (also called a variant or tagged sumtype).\n' +
		'\n' +
		'{name} = ' + str.join(
			'\n{indent}| ', Class._variant_reprs()
		) + '\n' +
		'\n'

	).format(
		name=name,
		indent=variant_def_indent
	)


	all_variant_fields = uniq( sum(Class._variant_id_fields, ()) )
	variant_ids_that_have_attr = {
		attr: [
			id_ for id_ in Class._variant_ids
			if attr in Class._variant_id_fields[id_]
		]
		for attr in all_variant_fields
	}

	real_attr_for_variant_id_and_field = {
		(id_, field): '_{}'.format(ix)
		for id_ in Class._variant_ids
			for (ix, field) in enumerate(Class._variant_id_fields[id_])
	}


	###########
	# codegen #
	###########

	# These methods could be implented without codegen,
	# but they're more efficient this way.
	# We prefer code duplication to needless allocations -
	# For example `._values()` could just call `._as_tuple()`,
	# but at the cost of allocating a tuple and then another one without the first value.
	# A compiler could skip creating that tuple because it
	# immediately gets deconstructed or inline the code, but Python is interpreted.

	if not _set_members_with_assignment:
		_set_attr = 'cls._unsafe_set_{attr}({obj}, {val})'
	else:
		_set_attr = '{obj}._{attr} = {val}'

	# ._values()

	mk_def_values = lambda variant_id_fields, variants: [
		'def _values(self) -> tuple:', [
			'_variant_id = self._variant_id',
			*cond(
				[ when("_variant_id == "+lit(id_), [
					"return " + tuple_( 'self._{}_{}'.format(variants[id_], field) for field in variant_id_fields[id_] )
				  ])
				  for id_ in variant_ids
				],
				default=['raise self.__class__._get_invalid_variant_error(_variant_id)'],
				allow_zero_cases=True
			)
		],
	]

	def_values = \
		flatten_tree(
			mk_def_values(
				variant_id_fields=Class._variant_id_fields,
				variants=Class._variants,
			)
		)
	if verbose:
		print(def_values, end='\n\n')

	_values = eval_def(def_values)
	Class._values = _values
	Class.values  = _values


	# ._as_tuple()

	mk_def_as_tuple = lambda variant_ids, variant_id_fields, variants: [
		'def _as_tuple(self) -> tuple:', [
			'_variant_id = self._variant_id',
			*cond(
				[ when("_variant_id == "+lit(id_), [
					"return " + tuple_(['_variant_id'] + [ 'self._{variant}_{field}'.format(variant=variant, field=field) for field in fields ])
				  ])
				  for (id_, variant, fields) in zip(variant_ids, variants, variant_id_fields)
				],
				default=['raise self.__class__._get_invalid_variant_error(_variant_id)'],
				allow_zero_cases=True
			)
		],
	]

	def_as_tuple = \
		flatten_tree(
			mk_def_as_tuple(
				variant_ids=Class._variant_ids, 
				variant_id_fields=Class._variant_id_fields, 
				variants=Class._variants, 
			)
		)
	if verbose:
		print(def_as_tuple, end='\n\n')
		
	_as_tuple = eval_def(def_as_tuple)
	Class._as_tuple = _as_tuple
	Class.as_tuple  = _as_tuple 
	Class._astuple  = _as_tuple # namedtuple convention
	Class.astuple   = _as_tuple


	# ._as_dict()

	mk_def_as_dict = lambda variant_ids, variant_id_fields, variants: [
		'def _as_dict(self) -> dict:', [
			'_variant_id = self._variant_id',
			*cond(
				[ when("_variant_id == "+lit(id_), [
					"return " + dict_([(lit('variant'), lit(variant))] + [ (lit(field), 'self._{variant}_{field}'.format(variant=variant, field=field)) for field in fields ])
				  ])
				  for (id_, variant, fields) in zip(variant_ids, variants, variant_id_fields)
				],
				default=['raise self.__class__._get_invalid_variant_error(_variant_id)'],
				allow_zero_cases=True
			)
		],
	]

	def_as_dict = \
		flatten_tree(
			mk_def_as_dict(
				variant_ids=Class._variant_ids, 
				variant_id_fields=Class._variant_id_fields, 
				variants=Class._variants, 
			)
		)
	if verbose:
		print(def_as_dict, end='\n\n')
		
	_as_dict = eval_def(def_as_dict)
	Class._as_dict = _as_dict
	Class.as_dict  = _as_dict 
	Class._asdict  = _as_dict # namedtuple convention
	Class.asdict   = _as_dict


	mk_def_replace = lambda typename, immutable, variant_ids, variants, variant_id_fields, _set_attr: [
		'def _replace(self, **fields_and_new_vals) -> '+lit(typename)+':', [
			'"""',
			"Analogous to `namedtuple`'s `_replace`.",
			"Returns a new value with fields modified according",
			"to the keyword arguments.",
			'"""',
			'cls = self.__class__',
			'new = cls.__new__(cls)',
			'',
			'variant_id = self._variant_id',
			# 'cls._unsafe_set_variant_id(new, variant_id)',
			_set_attr.format(obj='new', attr='variant_id', val='variant_id'),
			'',
			'# make local to avoid lookups',
			'fields_and_new_vals_pop = fields_and_new_vals.pop',
			'',
			*cond(
				[ when('variant_id == '+lit(id_), [
					_set_attr.format(obj='new', attr=(variant+'_'+field), val='fields_and_new_vals_pop("{field}", self._{attr})'.format(field=field, attr=(variant+'_'+field)))
					# ('cls._unsafe_set_{field_attr}(new, fields_and_new_vals_pop("{field}", self._{field_attr}))'
					#   if immutable else
					#  'new._{field_attr} = fields_and_new_vals_pop("{field}", self._{field_attr})') \
					# 	.format(field=field, field_attr=variant+'_'+field)
					 for field in variant_id_fields[id_]
					 # for (field_ix, field) in enumerate(variant_id_fields[id_])
				  ] + ['if not fields_and_new_vals: return new']) 
				 for (id_, variant) in zip(variant_ids, variants) if variant_id_fields[id_]
				],
				default=['raise cls._get_invalid_variant_error(variant_id)'],
				allow_zero_cases=True,
			),
			'',
			# 'if not fields_and_new_vals:', [
			# 	'return new',
			# ],
			# 'else:', [
			'first_bad_field = next(iter(fields_and_new_vals))',
			'if first_bad_field.startswith("_"):', [
				"# Catch this here. if __getattr__ sees this name,", 
				"# it will (correctly) guess that it can't be a field,",
				"# and will show the generic 'object doesn't have attribute x' error",
				"# However, if someone tries to `a._replace(_variant_id=15)`, the message will",
				"# be confusing, because the objects clearly *do* have a '_variant_id' attribute.", 
				'raise TypeError("_replace() can only modify fields, and \'{}\' is not a field".format(first_bad_field))',
			],
			'else:', [
				'# getattr should give a nice error message',
				'self.__getattr__(first_bad_field)',
			],
			# ],
		],
	]

	replace_ = \
		flatten_tree(
			mk_def_replace(
				typename=name,
				immutable=immutable,
				variant_ids=Class._variant_ids,
				variants=Class._variants,
				variant_id_fields=Class._variant_id_fields,
				_set_attr=_set_attr,
			)
		) 
	if verbose:
		print(replace_, end='\n\n')

	_replace = eval_def(replace_)
	Class._replace = _replace
	Class.replace  = _replace
	Class.set      = _replace
	Class.update   = _replace


	# match

	mk_def_replace2 = lambda variant_ids, variant_id_fields, variants, all_variant_fields: [
		'def _replace(self, '+str.join(', ', (field+'=...' for field in all_variant_fields))+'):', [
			
		]
	]

	mk_def_match = lambda variant_ids, variant_id_fields, variants, unused='...': [
		'def match(_self, '+(str.join(', ', (variant+'='+unused for variant in variants)) if variants else '*') +', _=...):', [
			'_variant_id = _self._variant_id',
			*cond(
				[
					when('_variant_id == '+lit(id_)+' and '+variant+' is not '+unused, [
						'return '+apply(variant, ['_self._'+variant+'_'+field for field in fields])
					])
					for (id_, variant, fields) in zip(variant_ids, variants, variant_id_fields)
				] + \
				[	
					when('_ is not '+unused, [
						'return _()'
					])
				],
				default=[
					'raise ValueError("Pattern match incomplete - no pattern for variant {self._variant}, and no default (`_`) provided".format(self=_self))'
				]
			)
		]
	]
	# mk_def_match = lambda variant_ids, variant_id_fields, variants, all_variant_fields, unused='...': [
	# 	'def match(_self, '+(str.join(', ', (variant+'='+unused for variant in variants)) if variants else '*') +', _=...):', [
	# 		'_case = '+tuple_(variants)+'[_self._variant_id]',
	# 		'if _case is not '+unused+':' ,[
	# 			'return _case(*_self._values())'
	# 		],
	# 		'elif _ is not '+unused+':' ,[
	# 			'return _()'
	# 		],
	# 		'else:', [
	# 			'raise ValueError("Pattern match incomplete - no pattern for variant {self._variant}, and no default (`_`) provided".format(self=_self))'
	# 		]

	# 	]
	# ]

	def_match = \
		flatten_tree(
			mk_def_match(
				variant_ids=Class._variant_ids, 
				variant_id_fields=Class._variant_id_fields, 
				variants=Class._variants, 
			)
		)
	if verbose:
		print(def_match, end='\n\n')
		
	_match = eval_def(def_match)
	Class._match = _match
	Class.match  = _match 

	# constructors
	if not _set_members_with_assignment:
		mk_def_constructor = lambda typename, id_, variant, fields, _set_attr: [
			def_(variant, ['_cls', *fields])[:-1]+' -> "'+typename+'":', [ # TODO: fix this hack (def_ doesn't support annotations right now) 
				'_val = _cls.__new__(_cls)',
				# _set_attr.format(obj='_val', attr='variant_id', _val=lit(id_)),
				'_cls._unsafe_set_variant_id(_val, {id_})'.format(id_=id_),
				*(
				# _set_attr.format(obj='_val', attr=variant+'_'+field, _val=field)
				"_cls._unsafe_set_{variant}_{field}(_val, {field})".format(variant=variant, field=field)
				for field in fields
				),
				'return _val',
			],
		]
	else:
		mk_def_constructor = lambda typename, id_, variant, fields, _set_attr: [
			def_(variant, ['_cls', *fields])[:-1]+' -> "'+typename+'":', [ # TODO: fix this hack (def_ doesn't support annotations right now) 
				'_val = _cls.__new__(_cls)',
				# _set_attr.format(obj='_val', attr='variant_id', _val=lit(id_)),
				# '_cls._unsafe_set_variant_id(_val, {id_})'.format(id_=id_),
				(
				tuple_(['_val._variant_id']+['_val._{}'.format(variant+'_'+field) for field in fields], parens=False)+\
				' = '+\
				tuple_((lit(id_),)+fields, parens=False)
				),
				'return _val',
			],
		]

	# __set_field = "val.{real_attr} = {field_arg}" 		  # fast, but doesn't work with defensive setattr 
	# __set_field = "cls.{real_attr}.__set__(val, {field_arg})" # slower because of the extra method lookup, but works with defensive setattr
	# ^ Uses property descriptors, because normal assignments are blocked to make the values more or less immutable


	# TODO:
	# Possible perf improvement:
	# Cache the descriptors' __set__ methods to skip one lookup.
	# This makes setting via descriptor call as fast as setting via '='. 
	# It introduces a bit of complexity though - it's another thing to
	# remember. Maybe add this after investigating Pickle integration.

	# Class.__set_variant_id = Class._variant_id.__set__
	# Class.__set_0 = Class._0.__set__
	# Class.__set_1 = Class._1.__set__

	constructors = []
	for (id_, variant) in zip(Class._variant_ids, Class._variants):
		fields = Class._variant_id_fields[id_]
		_def_constructor = \
			flatten_tree(
				mk_def_constructor(
					typename=name,
					id_=id_,
					variant=variant,
					fields=fields,
					_set_attr=_set_attr
				)
			)

		if verbose:
			print(_def_constructor, end='\n\n')

		assert not hasattr(Class, variant), "'{}' already defined. Class dir:\n{}".format(variant, dir(Class))
		constructor = eval_def(_def_constructor)
		constructor.__qualname__ = '{}.{}'.format(name, constructor.__name__)
		setattr(Class, variant, classmethod(constructor))
		constructors.append(constructor)

	Class._constructors = tuple(constructors)


	# .is_Foo(), is_Bar(), etc. methods for pattern mathing 

	mk_def_is_some_variant = lambda id_, variant: [
		'def is_'+variant+'(self) -> bool:', [
			'return self._variant_id == '+lit(id_),
		]
	]

	for (id_, variant) in zip(Class._variant_ids, Class._variants):
		_def_is_some_variant = flatten_tree(mk_def_is_some_variant(id_=id_, variant=variant))
		if verbose:
			print(_def_is_some_variant, end='\n\n')
		is_some_variant = eval_def(_def_is_some_variant)
		is_some_variant.__qualname__ = '{}.{}'.format(name, is_some_variant.__name__)
		setattr(Class, 'is_'+variant, is_some_variant)



	# field getters

	mk_def_getter = lambda field, valid_variant_ids, variants: [
		def_(field, ['self']), [
			'variant_id = self._variant_id',
			*cond(
				[ when('variant_id == '+lit(id_), [
					'return self._{variant}_{field}'.format(variant=variants[id_], field=field)
				  ])
	              for id_ in valid_variant_ids
				],
				default=['raise AttributeError()'], # the AttributeError gets swallowed by the interpreter, and __getattr__ is called as a fallback
				allow_zero_cases=True, # default for classes with no variants (unusual but possible)
			),
		]
	]

	for field in all_variant_fields:
		valid_variant_ids = variant_ids_that_have_attr[field]
		assert len(valid_variant_ids) >= 1, \
			"Internal error creating {name}:\n" + \
			"field {field} is present in `all_variant_fields` even though no variants seem have it.\n" + \
			"Debug:\n"+\
			"variant_specs = {variant_specs}\n" + \
			"all_variant_fields = {all_variant_fields}\n" + \
			"variant_ids_that_have_attr={variant_ids_that_have_attr}\n" \
				.format(**locals())

		_def_getter = \
			flatten_tree(
				mk_def_getter(
					field=field,
					valid_variant_ids=valid_variant_ids,
					variants=Class._variants,
				)
			)

		if verbose:
			print(_def_getter, end='\n\n')

		assert not hasattr(Class, field), "'{}' already defined. Class dir:\n{}".format(field, dir(Class))
		getter = eval_def(_def_getter)
		getter.__qualname__ = '{}.{}'.format(name, getter.__name__)

		setattr(Class, field, property(getter))



	# unsafe accessors

	for (id_, variant) in zip(Class._variant_ids, Class._variants):
		for field in Class._variant_fields[variant]:
			unsafe_accessor_descriptor = getattr(Class, real_attr_for_variant_id_and_field[(id_, field)])
			
			unsafe_accessor_name = '_{var}_{field}'.format(var=variant, field=field)
			setattr(Class, unsafe_accessor_name, unsafe_accessor_descriptor)
			
			# works like a classmethod
			unsafe_setter_name = '_unsafe_set'+unsafe_accessor_name
			setattr(Class, unsafe_setter_name, unsafe_accessor_descriptor.__set__)

	# works like a classmethod
	Class._unsafe_set_variant_id = Class._variant_id.__set__

	# Collect the `_0, _1, _2, ...` descriptors in one place - comes in handy sometimes 
	Class._positional_descriptors = tuple(getattr(Class, '_{}'.format(field_ix)) for field_ix in range(max_n_fields))


	# __repr__

	mk_def_repr = lambda typename, variant_ids, variants, variant_id_fields: [
		'def __repr__(self) -> str:', [
			'variant_id = self._variant_id',
			*cond(
				[ when('variant_id == '+lit(id_), [
						# reuse `apply` to build something like 'return "Foo(x={self.x})".format(self=self)'
						# because it's good for `foo(a=x, b=y)` syntax
						'return "' \
						+ apply(typename+'.'+variant, kwargs=[(field, '{self._'+variant+'_'+field+'!r}') for field in variant_id_fields[id_]]) \
						+ '".format(self=self)'
						# + apply(variant, [(field, '{self._'+variant+'_'+field+'}') for field in fields]) \
				  ])
			 	  for (id_, variant) in zip(variant_ids, variants)
			 	],
				default=['raise self.__class__._get_invalid_variant_error(variant_id)'],
				allow_zero_cases=True,
			)
		]
	]

	_def_repr = \
		flatten_tree(
			mk_def_repr(
				typename=name,
				variant_ids=Class._variant_ids,
				variants=Class._variants,
				variant_id_fields=Class._variant_id_fields
			)
		)

	if verbose:
		print(_def_repr, end='\n\n')


	
	__repr__ = eval_def(_def_repr)
	__repr__.__qualname__ = '{}.{}'.format(name, __repr__.__name__)
	Class.__repr__ = __repr__


	# __eq__

	mk_def_eq = lambda variant_ids, variants, variant_id_fields: [
		'def __eq__(a, b) -> bool:', [
			'if a.__class__ is not b.__class__:', [
				'return NotImplemented',
			],
			'',
			'a_variant_id = a._variant_id',
			'b_variant_id = b._variant_id',
			'if a_variant_id != b_variant_id:', [
				'return False',
			],
			'',
			*cond(
				[ when("a_variant_id == "+lit(id_), [
						# either "return (a._0 == b._0) and (a._1 == b._1) and ...""
						# or     "return True" if a variant has no fields
						"return " + \
							join_with_op(
								('a._{variant}_{field} == b._{variant}_{field}'.format(variant=variant, field=field)
								 	    for field in fields
								),
								op='and',
								zero='True',
							),
				  ])
				  for (id_, variant, fields) in zip(variant_ids, variants, variant_id_fields)
				],
				default=['raise self.__class__._get_invalid_variant_error(variant_id)'],
				allow_zero_cases=True
			)
		],
	]

	
	_def_eq = \
		flatten_tree(
			mk_def_eq(
				variant_ids=Class._variant_ids, 
				variants=Class._variants, 
				variant_id_fields=Class._variant_id_fields,
			)
		)

	if verbose:
		print(_def_eq, end='\n\n')

	__eq__ = eval_def(_def_eq)
	__eq__.__qualname__ = '{}.{}'.format(name, __eq__.__name__)
	Class.__eq__ = __eq__


	# __setstate__

	mk_def_setstate = lambda typename, variant_ids, variants, variant_id_fields, _set_attr: [
		'def __setstate__(self, state: tuple) -> None:', [
			'cls = self.__class__',
			'variant_id = state[0]',
			_set_attr.format(obj='self', attr='variant_id', val='variant_id'),
			# 'cls._unsafe_set_variant_id(self, variant_id)',
			*cond(
				[ when('variant_id == '+lit(id_), [
					tuple_(['_']+['new_'+field for field in fields])+' = state'  
				  ]+[
					_set_attr.format(obj='self', attr=variant+'_'+field, val='new_'+field)
					# 'cls._unsafe_set_{variant}_{field}(self, new_{field})'\
					# 	.format(field=field, variant=variant)
					 for field in fields
					 # for (field_ix, field) in enumerate(variant_id_fields[id_])
				  ]+['return'])
				 for (id_, variant, fields) in zip(variant_ids, variants, variant_id_fields) if fields
				],
				default=['raise cls._get_invalid_variant_error(variant_id)'],
				allow_zero_cases=True,
			),
		],
	]

	_def_setstate = \
		flatten_tree(
			mk_def_setstate(
				typename=name,
				variant_ids=Class._variant_ids,
				variants=Class._variants,
				variant_id_fields=Class._variant_id_fields,
				_set_attr=_set_attr,
			)
		) 
	if verbose:
		print(_def_setstate, end='\n\n')
	
	__setstate__ = eval_def(_def_setstate)
	__setstate__.__qualname__ = '{}.{}'.format(name, __setstate__.__name__)
	Class.__setstate__ = __setstate__



	return Class





def uniq(xs: List[A]) -> List[A]:
	""" Like set(xs), but order-preserving.""" 
	seen = set()
	res = []
	for x in xs:
		if x not in seen:
			res.append(x)
			seen.add(x)
	return res




UNSAFE_ACCESSORS_README = """
Thing._Foo_x   = Thing._0
Thing._Foo_y   = Thing._1
...

In contrast with the regular accessors like .x, .y, these will *NOT* check 
if they were called on the correct variant. They can be used for speed
if you know that the variant of a value.
Note, however, that they may silently return incorrect results
when used on an incorrect variant.

	>>> # class Thing = Foo(x, y, z) | Bar(a, z)
	>>>
	>>> # Correct - accessing Bar fields on a Bar value:
	>>>
	>>> # checked access - will error for variants that don't have the field
	>>> # (still very fast)
	>>> Bar(a=3, z=10).a 
	3
	>>> Bar(a=3, z=10).z
	10
	>>> # unchecked access - assumes the value is a Bar
	>>> # A bit faster, but can hide bugs 
	>>> Bar(a=3, z=10)._Bar_a
	3
	>>> # Note that even though the two variants share a field name,
	>>> # everything works correctly 
	>>> Bar(a=3, z=10)._Bar_z
	10
	>>> Foo(x=7, y=8, z=9)._Foo_z
	9
	>>>
	>>>
	>>> # Incorrect - accessing Foo fields on a Bar value
	>>>
	>>> # safe accessors will catch incorrect accesses:
	>>> Bar(a=3, z=10).x
	AttributeError(...)
	>>> Bar(a=3, z=10).y
	AttributeError(...)
	>>> # But unsafe ones won't:
	>>> Bar(a=3, z=10)._Foo_x	# assumes the value is a Foo, silently returns an incorrect result
	3
	>>> Bar(a=3, z=10)._Foo_y	# assumes the value is a Foo, silently returns an incorrect result
	10
	>>> Bar(a=3, z=10)._Foo_z 	# errors because of implementation details 
	AttributeError(...)
	>>>
	>>> # Incorrect - accessing Bar fields on a Foo value
	>>>
	>>> Foo(x=10, y=15).a 		# safe accessors will catch incorrect accesses
	AttributeError(...)
	>>> Foo(x=10, y=15)._Bar_a	# assumes the value is a Bar, silently returns an incorrect result
	10
"""









def main():
	from dis import dis

	# Void, = untyped_sumtype('Void', [], verbose=True, allow_zero_constructors=True)
	# # print(dir(Void))
	# print('\n\n')
	# Void has no constructors, so it can't be instantiated.
	# Mostly useless, but the fact that it works gives me a certain peace of mind about the codegen :)
	# (inspired by Haskell, just like this whole module)

	Thing = untyped_sumtype(
	'Thing',
	[
		('Foo', ['x', 'y',]),
		('Bar', ['y',     ]),
		('Zip', ['hey',   ]),
		('Hop', []         ),
	],
	 verbose=True,
	 immutable=False,
	 _set_members_with_assignment=True,
	)

	print('__name__     : ', Thing.__name__)
	print('__qualname__ : ', Thing.__qualname__)
	print('__module__   : ', Thing.__module__)
	# print('__doc__:', Thing.__doc__, sep='\n')
	# help(Thing)
	print('_positional_descriptors:', getattr(Thing, '_positional_descriptors', None))
	# print(dir(Thing))

	print()
	dis_func = Thing.match
	print('dis(%s):' % dis_func.__qualname__)
	print()
	dis(dis_func)
	print()
	
	foo = Thing.Foo(3, 5)
	bar = Thing.Bar("nice")
	zip = Thing.Zip(15.234)
	hop = Thing.Hop()


	print("Attribute access:")
	all_variant_fields = uniq( sum((Thing._variant_fields[variant] for variant in Thing._variants), ()) )

	for val in ('foo', 'bar', 'zip', 'hop'):
		val_ = eval(val)
		print("\t{}".format(val_))
		for field in all_variant_fields:
			should_work = (field in Thing._variant_fields[val_.variant])
			expr = "{val}.{field}".format(**locals())
			try:
				res = eval(expr)
				did_work = True
			except AttributeError as e:
				res = e
				did_work = False

			print(
				"\t\t{should}{did} {expr:<10}: {res!r}".format(
					expr=expr, res=res,
					should={True: '+', False: '-'}[should_work],
					did={True: '+', False: '-'}[did_work]
				)
			)

			assert should_work == did_work

			# print()
		expr = '{val}.{bad}'.format(val=val, bad=str.join('', all_variant_fields))
		try: res = eval(expr)
		except AttributeError as e: res = e
		print(
			"\t{expr:<10}: {res!r}".format(
				expr=expr, res=res,
			)
		)
		print()
		print()




	print()
	print(foo, bar, zip, hop, sep='\n')
	# Thing._variant_id.__set__(foo, 5)
	print("x==x:", foo==foo, bar==bar, zip==zip, hop==hop)
	print("V(*args) == V(*args):", Thing.Foo(3,5) == Thing.Foo(3,5))
	print("V(*args1) == V(*args2):", Thing.Foo(3,5) == Thing.Foo(0,10))
	print("X(*args) == Y(*args)", Thing.Bar(3) == Thing.Zip(3))
	print()
	foo2 = foo._copy()
	print("x, x.copy(), x is x.copy():", foo, foo2, foo is foo2, sep=', ')
	bar2 = bar._copy()
	print("x, x.copy(), x is x.copy():", bar, bar2, bar is bar2, sep=', ')
	zip2 = zip._copy()
	print("x, x.copy(), x is x.copy():", zip, zip2, zip is zip2, sep=', ')
	hop2 = hop._copy()
	print("x, x.copy(), x is x.copy():", hop, hop2, hop is hop2, sep=', ')
	bar2 = bar.replace(y="better")
	print("replace:", bar, bar2)
	print("x.is_X()", foo.is_Foo(), bar.is_Bar(), zip.is_Zip())
	print("x.is_Y()", foo.is_Bar(), bar.is_Zip(), zip.is_Foo())

	try: res = bar.replace(blah_blah_blah=5)
	except Exception as e: res = e
	print("bad replace 1:", bar, repr(res))

	try: res = bar.replace(_0=5)
	except Exception as e: res = e
	print("bad replace 2:", bar, repr(res))

	try: res = bar.replace(_variant_id=5)
	except Exception as e: res = e
	print("bad replace 2:", bar, repr(res))

	foo_ = Thing.Foo(3, 5)
	try:
		Thing._variant_id.__set__(foo_, 15)
		res = repr(foo_)
	except Exception as e:
		res = e
	print("repr of bad variant:", repr(res))

	foo_ = Thing.Foo(3, 5)
	Thing._unsafe_set_Foo_x(foo_, 10)
	print('unsafe set: Foo(3, 5) ->', foo_)
	# del foo._Foo_y
	# print(foo)

	# foo._Foo_y = 10
	# print(foo)

	# Profiling

	import timeit
	from sumtype_plain_tuple import untyped_sumtype as untyped_sumtype_tuple

	Thing2 = untyped_sumtype_tuple(
	'Thing2', [
		('Foo', ('x', 'y',)),
		('Bar', ('y',)),
		('Zip', ('hey',)),
	])


	create_3_variants = """
foo = Thing.Foo(3, 5)
bar = Thing.Bar("nice")
zip = Thing.Zip(15.234)
"""
	create_3_variants_kwargs = """
foo = Thing.Foo(x=3, y=5)
bar = Thing.Bar(y="nice")
zip = Thing.Zip(hey=15.234)
"""

	access_attributes = """
x = foo.x
# y = foo.y
# y = bar.y
# z = zip.hey
"""
	unsafe_access_attributes = """
x = foo._Foo_x
# y = foo._Foo_y
# y = bar._Bar_y
# z = zip._Zip_hey
"""

	replace_all_attributes = """
foo2 = foo.replace(x=4)
# foo2 = foo.replace(x=4, y=6)
# bar2 = bar.replace(y="nicer")
# zip2 = zip.replace(hey=3.141592)
"""

	copy = """
foo2 = foo._copy()
# bar2 = bar._copy()
# zip2 = zip._copy()
"""
	# make the classes accessible to timeit
	# (they're created within `main()`, so they're not visible otherwise)
	globals()['Thing']  = Thing
	globals()['Thing2'] = Thing2

	slot_sumtype_setup  = "from __main__ import Thing"
	tuple_sumtype_setup = "from __main__ import Thing2 as Thing"


	n_timing_repetitions = 100001

	tests = (
		('slot_sumtype_create_3',          create_3_variants,        slot_sumtype_setup),
		('tuple_sumtype_create_3',         create_3_variants,        tuple_sumtype_setup),

		# ('slot_sumtype_create_3_kwargs',   create_3_variants_kwargs, slot_sumtype_setup),
		# ('tuple_sumtype_create_3_kwargs',  create_3_variants_kwargs, tuple_sumtype_setup),

		('slot_sumtype_access_all',        access_attributes,        slot_sumtype_setup +create_3_variants),
		('tuple_sumtype_access_all',       access_attributes,        tuple_sumtype_setup+create_3_variants),
		('slot_sumtype_unsafe_access_all', unsafe_access_attributes, slot_sumtype_setup +create_3_variants),

		('slot_sumtype_copy',              copy,                     slot_sumtype_setup +create_3_variants),
		('tuple_sumtype_copy',             copy,                     slot_sumtype_setup +create_3_variants),

		('slot_sumtype_replace_all_attributes',          replace_all_attributes,        slot_sumtype_setup +create_3_variants),
		('tuple_sumtype_replace_all_attributes',         replace_all_attributes,        tuple_sumtype_setup+create_3_variants),
	)
	print("Profiling")
	for (name, code, setup) in tests:
		time_usec = timeit.timeit(
			code,
			setup=setup,
			number=n_timing_repetitions
		) * 1000000 / n_timing_repetitions
		print('\t{name}:\t{time_usec:.2f} usec'.format(**locals()))

if __name__ == '__main__':
	main()


