from typing import (
	Any,
	Tuple, List, Iterator, Union, Optional,
	Callable,
	TypeVar,
	NoReturn, # functions that always raise or exit the interpreter 
)

from indented.text    import flatten_tree
from indented.codegen import (
	lit, apply, 
	tuple_, list_, # dict_,
	def_, cond, when,
	join_with_op,
	eval_def,
)

import typeguard

Fun = Callable
A = TypeVar('A')

# import functools
from functools import partial

from collections import OrderedDict
import sys
from warnings import warn
import inspect
from keyword import iskeyword


__all__ = [
	'sumtype',
	'untyped_sumtype',
]

def is_typelike(t)    -> bool: return is_simple_type(t) or is_typing_type(t)
def is_simple_type(t) -> bool: return type(t) is type
def is_typing_type(t) -> bool: return type(t).__module__ == 'typing'
def is_anylike(t)     -> bool: return t is object or t is Any


def name_errors(name: str, use: str = '') -> List[str]:
	errors = []
	if name.startswith('_'):
		errors.append("Invalid {use} name: {name!r} - {use} names cannot contain leading underscores".format(**locals()))
	if not name.isidentifier():
		errors.append("Invalid {use} name: {name!r} - {use} names must be valid Python identifiers".format(**locals()))
	return errors


	
def typed_spec_errors(typename: str, variant_specs: List[  Tuple[str, List[Tuple[str, type]] ]  ]) -> List[str]:
	assert type(typename) is str,  repr(typename)
	errors = name_errors(typename, use='type')
	seen_variants = set()
	for (variant, fields_and_types) in variant_specs:
		assert type(variant) is str,  repr(variant)
		assert type(fields_and_types) in (list, tuple),  repr(fields_and_types)
		errors.extend(name_errors(variant, use='variant'))

		if variant in seen_variants:
			errors.append("Repeated variant name {!r} in type {!r}".format(variant, typename))
		else:
			seen_variants.add(variant)

		seen_fields = set()
		for (field, type_) in fields_and_types:
			assert type(field) is str, repr(field)
			assert is_typelike(type_), "{!r} ({!r})".format(type_, type(type_)) 
			errors.extend(name_errors(field, use='field'))
			if field in seen_fields:
				errors.append("Repeated field name {!r} in variant {!r}".format(field, variant))
			else:
				seen_fields.add(field)

	return errors


import builtins
builtin_types = set(v for n in dir(builtins) for v in (getattr(builtins, n),) if type(v) is type)

def type_literal(t) -> str:
	assert is_typelike(t), repr(t)
	if t in builtin_types:
		return t.__name__
	elif type(t).__module__ == 'typing':
		return repr(t)
	else:
		return t.__qualname__



def untyped_sumtype(
		typename: str,
		variant_specs: List[ Tuple[str, List[str]] ],
		*,
		verbose=False,
		allow_zero_constructors=False,
		_module_name=None
	) -> type:

	
	variant_specs = [(variant_name, [(attr_name, Any) for attr_name in attr_names])
					 for (variant_name, attr_names) in variant_specs]

	# module name

	# `untyped_sumtype` relies on sys._getframe to inspect the caller's frame and
	# get the right module name. That won't work if `sumtype` calls it,
	# since the caller's frame will be located in this module.
	# So we have to get the module name here, and pass it down.				 
	if _module_name is None:
		try:
			_module_name = sys._getframe(1).f_globals.get('__name__', '__main__')
		except (AttributeError, ValueError):
			warn(
				RuntimeWarning(
					"Cannot access the caller's module name"+
					" - pickle will likely have trouble unpickling {} objects".format(typename)
				)
			)
			_module_name = '<generated by sumtype>'


	return \
		sumtype(
			typename,
			variant_specs,
			typecheck='never',
			# pass the rest through unchanged
			verbose=verbose,
			allow_zero_constructors=allow_zero_constructors,
			_module_name=_module_name,
		) 




def sumtype(
		typename: str,
		variant_specs: List[  Tuple[str, List[Tuple[str, type]] ]  ],
		*,
		typecheck='always',
		verbose=False,
		allow_zero_constructors=False,
		_module_name=None
	) -> type:
	"""
	`typecheck` must be one of ('always', 'debug', 'never')
	"""

	if not allow_zero_constructors and not variant_specs:
		raise ValueError(
			'No variants specified - probably a bug. '
			+'Pass `allow_zero_constructors=False` to allow this.'
		)
		
	errors = typed_spec_errors(typename, variant_specs)
	if errors:
		raise ValueError('\n'.join(errors))

	# useful for the typed version:
	variant_names      = [variant_name         for (variant_name, _)         in variant_specs]
	variant_attr_specs = [attr_names_and_types for (_, attr_names_and_types) in variant_specs]
	variant_attr_names = [[attr_name for (attr_name, _) in attr_names_and_types]
						  for attr_names_and_types in variant_attr_specs]
	variant_attr_types = [[attr_type for (_, attr_type) in attr_names_and_types]
						  for attr_names_and_types in variant_attr_specs]

	typecheck_opts = {
		'always': typeguard.typechecked(always=True),
		'debug' : typeguard.typechecked,
		'never' : (lambda x: x),
	}
	maybe_typechecked = typecheck_opts.get(typecheck, None)
	if maybe_typechecked is None:
		raise ValueError(
			"Argument 'typecheck' must be one of {!r}; got {!r}"\
				.format(tuple(typecheck_opts.keys()))
		)

	# variant_attr_names = [attr_names for (variant_name, attr_names) in variant_specs]
	variant_ids = range(len(variant_names))


	max_n_fields = max((len(attrs) for attrs in variant_attr_names), default=0)
	slots = ('_variant_id',) + tuple('_{}'.format(i) for i in range(max_n_fields))
	if verbose:
		print('class {}:'.format(typename))
		print('__slots__ =', slots, end='\n\n')
		print('...', end='\n\n')



	class Class:
		__slots__ = slots
		_variants    = variant_names
		_variant_ids = tuple(variant_ids)
		_variant_fields = OrderedDict(
			(name, tuple(fields))
			for (name, fields) in zip(variant_names, variant_attr_names)
		)
		_variant_field_types = OrderedDict(
			(name, tuple(types))
			for (name, types) in zip(variant_names, variant_attr_types)		
		)
		_variant_specs = OrderedDict(
			(name, tuple(fields_and_types))
			for (name, fields_and_types) in zip(variant_names, variant_attr_specs)		
		)

		_variant_id_fields = tuple(tuple(field_names) for field_names in variant_attr_names)
		_variant_id_types  = tuple(tuple(field_types) for field_types in variant_attr_types)

		ARGUMENT_UNUSED = object() # used to test if a keyword argument was passed or not
		# _variants            = _variants   
		# _variant_ids         = _variant_ids
		# _variant_fields      = _variant_fields
		# _variant_field_types = _variant_field_types
		# _variant_specs       = _variant_specs
		# _variant_id_fields   = _variant_id_fields

		# ARGUMENT_UNUSED = ARGUMENT_UNUSED


		def raise_direct_init_forbidden(self) -> NoReturn:
			""" Objects of this class can only be created with its constructor-classmethods. """
			cls = self.__class__
			raise TypeError(
				'Cannot instantiate {type!r} directly '+
				'- use one of the variant constructors: {vars}'.format(
					type=cls.__name__, vars=cls._variants_repr()
				)
			)
		__init__ = raise_direct_init_forbidden


		@property
		def _variant(self) -> str:
			"The name of the variant"
			return self.__class__._variants[self._variant_id]
		variant = _variant


		@property
		def _constructor(self):
			"The constructor used to build self"
			cls = self.__class__
			return getattr(cls, self._variant)
		

		def _values_dict(self) -> OrderedDict:
			dct = self._as_dict()
			del dct['variant']
			return dct

		values_dict = _values_dict


		@classmethod
		def _from_tuple(cls, tup: tuple) -> typename:
			variant, values = tup[0], tup[1:]
			constructor = getattr(cls, variant)
			return constructor(*values)
			
		from_tuple = _from_tuple


		@classmethod
		def _from_dict(cls, dct: dict) -> typename:
			dct_ = dct.copy()
			variant = dct_.pop('variant')
			constructor = getattr(cls, variant)
			return constructor(**dct_)
			
		from_dict = _from_dict


		def __hash__(self):
			return hash(self._as_tuple())


		def __copy__(self) -> typename:
			""" Returns a shallow copy of self. """
			cls = self.__class__

			new = cls.__new__(cls)
			new.__setstate__(self.__getstate__())
			return new

		_copy = __copy__
		copy  = __copy__
		

		# Pickle methods
		# 	We used __getstate__ and __setstate__ instead of __getnewargs__
		#	because even after calling __new__ the correct arguments,
		#	pickle tried to manually set each attribute from __slots__,
		#	which didn't work because __setattr__ blocks all modification attempts.
		#	__(get/set)state__ make pickle back off and let us handle all initialization. 


		# Methods that always raise

		def _impossible(self, msg: Optional[str] = None) -> NoReturn:
			"A helper for raising errors related to unexpected variants"
			cls = self.__class__
			if self._variant_id not in cls._variant_ids:
				raise self.__class__._get_invalid_variant_error(self._variant_id)
			elif msg:
				raise RuntimeError(msg)
			else:
				raise RuntimeError('Value {!r} should never occur here'.format(self))

		impossible = _impossible


		def _raise_error_missing_descriptor(self, attr: str) -> NoReturn:
			"""
			A fake __getattr__ implemented only to give better error messages.
			Will always raise an exception, because if it was called, one of the
			following is true:
			- the class has no data descriptor for `attr`
			- the class has a data descriptor for `attr`, but the descriptor raised AttributeError()
				(e.g. the user tried to access an uninitialized slot)
			"""

			cls = self.__class__

			if cls._is_unsafe_accessor_name(attr):
				attr = cls._extract_field_from_unsafe_accessor_name(attr)

			ex = None
			if any(attr in fields for fields in cls._variant_fields.values()):
				# A data descriptor for 'attr' exists, but it raised AttributeError()
				# and the interpreter called __getattr__ as a fallback
				ex = AttributeError(
					"Incorrect '{type}' variant: "+
					"Field '{attr}' not declared in variant '{var}'. Variants: {vars}".format(
						attr=attr, var=self._variant,
						type=cls.__qualname__, vars=cls._variants_repr(),
					),
				)
			elif cls._is_permitted_sumtype_field_name(attr):
				# No data descriptor for 'attr' exists - 
				# if we didn't create it, then there's no attribute with
				# this name in any variant
				ex = AttributeError(
					"Unknown attribute: "+
					" Field '{attr}' not declared in any variant of '{type}': {vars}".format(
						attr=attr, type=cls.__qualname__, vars=cls._variants_repr(),
					) 
				)
			else: # Couldn't possibly be a field - probably a typo or nonexistent method
				ex = AttributeError(
					"'{type}' object has no attribute '{attr}'"\
						.format(type=cls.__qualname__, attr=attr,)
				)

			raise ex
		__getattr__ = _raise_error_missing_descriptor



		def _raise_setattr_forbidden(self, attr: str, val) -> NoReturn:
			"""
			A fake __setattr__ implemented only to give better error messages
			for attribute modification attempts.
			"""
			raise TypeError(
				"Cannot modify '{type}' values. "+
				"Use `myval2 = myval.replace(attr=x)` instead. "+
				"(Tried to set {self}.{field} = {val!r})"\
					.format(
						type=self.__class__.__qualname__, self=self, field=attr, val=val,
					)
			)
		__setattr__ = _raise_setattr_forbidden



		def _raise_delattr_forbidden(self, attr: str) -> NoReturn:
			"""
			A fake __delattr__ implemented only to give better error messages
			for attribute modification attempts.
			"""
			raise TypeError(
				"Cannot modify '{type}' values.".format(
					type=self.__class__.__qualname__,
				)
			)
		__delattr__ = _raise_delattr_forbidden

		
		@classmethod
		def _variant_reprs(cls) -> Iterator[str]:
			return (
				"{var}({fields})".format(
					var=variant,
					fields=str.join(
						', ',
						(field+': '+type_literal(type_)
						 for (field, type_) in cls._variant_specs[variant])
					)
				)
				for variant in cls._variants
			)


		# Error message helpers

		@classmethod
		def _variants_repr(cls) -> str:
			"Used to display all the variants in error messages."
			return str.join(', ', cls._variant_reprs())

		@classmethod
		def _is_permitted_sumtype_field_name(cls, field: str) -> bool:
			return not field.startswith('_') and not iskeyword(field)


		@classmethod
		def _is_unsafe_accessor_name(cls, field: str) -> bool:
			""" '_Foo_x' -> True """
			return any(field.startswith('_{}_'.format(variant)) for variant in cls._variants)

		@classmethod
		def _extract_field_from_unsafe_accessor_name(cls, field: str) -> str:
			return field.split('_', maxsplit=2)[2]

		@classmethod
		def _get_invalid_variant_error(cls, variant_id) -> Exception:
			return RuntimeError(
				"Internal error: {id} is not a valid '{type}' variant id  (ids: {ids})".format(
					type=cls.__qualname__, id=variant_id, ids=cls._variant_ids,
				)
			)
			

	# end class


	# class name
	Class.__name__     = typename
	Class.__qualname__ = typename

	if _module_name is None:
		# caller of `sumtype` didn't pass a module name - get the caller's module name
		try:
			_module_name = sys._getframe(1).f_globals.get('__name__', '__main__')
		except (AttributeError, ValueError):
			warn(
				RuntimeWarning(
					"`untyped_sumtype` can't access the caller's module name - "+
					"pickle will likely have trouble unpickling {!r} objects".format(typename)
				)
			)
			_module_name = '<generated by sumtype>' # fallback

	Class.__module__ = _module_name

	indent = ' ' * (len(typename) + 1)
	Class.__doc__ = flatten_tree(
		[
			'A sum type (also called a variant or tagged union).',
			'',
			typename+' = ' + str.join(
				'\n'+indent+'| ', Class._variant_reprs()
			) + '\n',
			'',
		]
	)

	# fix the qualnames and modules of the methods defined above

	for name in dir(Class):
		val = getattr(Class, name)
		if (not inspect.isroutine(val)
			or inspect.ismethoddescriptor(val) and val.__objclass__ is not Class):
			continue

		if inspect.ismethod(val):
			val = val.__func__
		if val.__module__ == __name__:
			val.__module__ = _module_name
			val.__qualname__ = typename+'.'+val.__name__

	Class.assert_type = typeguard.check_type


	all_variant_fields = uniq( sum(Class._variant_id_fields, ()) )
	variant_ids_that_have_attr = {
		attr: [
			id_ for id_ in Class._variant_ids
			if attr in Class._variant_id_fields[id_]
		]
		for attr in all_variant_fields
	}

	real_attr_for_variant_id_and_field = {
		(id_, field): '_{}'.format(ix)
		for id_ in Class._variant_ids
			for (ix, field) in enumerate(Class._variant_id_fields[id_])
	}


	###########
	# codegen #
	###########

	# These methods could be implented without codegen,
	# but they're more efficient this way.
	# We prefer code duplication to needless allocations -
	# For example `._values()` could just call `._as_tuple()`,
	# but at the cost of allocating a tuple and then another one without the first value.
	# A compiler could skip creating that tuple because it
	# immediately gets deconstructed or inline the code, but Python is interpreted.

	_set_attr = 'cls._unsafe_set_{attr}({obj}, {val})'

	# template function for multiple functions that just pack the fields into a structure and return it

	mk_def_convert = lambda func_name, ret_type, mk_result, variant_ids, variant_id_fields, variants: [
		'def '+func_name+'(self) -> '+ret_type+':', [
			'_variant_id = self._variant_id',
			*cond(
				[ when("_variant_id == "+lit(id_), [
					"return " + mk_result(
						selfname='self',
						id_varname='_variant_id',
						id_=id_,
						variant=variant, fields=fields)
					# "return " + tuple_(
					#	['_variant_id'] + [ 'self._{variant}_{field}'.format(variant=variant, field=field) for field in fields ])
				  ])
				  for (id_, variant, fields) in zip(variant_ids, variants, variant_id_fields)
				],
				default=['raise self.__class__._get_invalid_variant_error(_variant_id)'],
				allow_zero_cases=True
			)
		],
	]
	mk_def_convert = partial(
			mk_def_convert,
			variant_ids=Class._variant_ids,
			variant_id_fields=Class._variant_id_fields,
			variants=Class._variants
	)


	#._values()

	mk_values_result = lambda selfname, id_varname, id_, variant, fields: \
		tuple_( '{s}._{v}_{f}'.format(s=selfname, v=variant, f=field) for field in fields)
	def_values = \
		flatten_tree(
			mk_def_convert(
				func_name='values',
				ret_type='tuple',
				mk_result=mk_values_result,
			)
		)

	if verbose:
		print(def_values, end='\n\n')

	_values = eval_def(def_values)
	_values.__qualname__ = typename+'.'+_values.__name__
	_values.__module__ = _module_name
	Class._values = _values
	Class.values  = _values


	# ._as_tuple()

	mk_as_tuple_result = lambda selfname, id_varname, id_, variant, fields: \
		tuple_([lit(variant)]+['{s}._{v}_{f}'.format(s=selfname, v=variant, f=field) for field in fields])

	def_as_tuple = \
		flatten_tree(
			mk_def_convert(
				func_name='_as_tuple',
				ret_type='tuple',
				mk_result=mk_as_tuple_result,
			)
		)
	if verbose:
		print(def_as_tuple, end='\n\n')
		
	_as_tuple = eval_def(def_as_tuple)
	_as_tuple.__qualname__ = typename+'.'+_as_tuple.__name__
	_as_tuple.__module__ = _module_name
	Class._as_tuple = _as_tuple
	Class.as_tuple  = _as_tuple 
	Class._astuple  = _as_tuple # namedtuple convention
	Class.astuple   = _as_tuple


	# ._as_dict()
	Class._OrderedDict = OrderedDict
	mk_as_dict_result = lambda selfname, id_varname, id_, variant, fields: \
		apply(selfname+'.__class__._OrderedDict', [
			tuple_(
				[tuple_([lit('variant'), lit(variant)])]
				+
				[ tuple_([lit(field), '{selfname}._{variant}_{field}'\
											.format(selfname=selfname, variant=variant, field=field)])
				  for field in fields ]
			)
		])

	# mk_as_dict_result = lambda selfname, id_varname, id_, variant, fields: \
	# 	dict_(
	# 		[(lit('variant'), lit(variant))] +
	# 		[ (lit(field), '{selfname}._{variant}_{field}'\
	# 							.format(selfname=selfname, variant=variant, field=field))
	# 		  for field in fields ]
	# 	)
	def_as_dict = \
		flatten_tree(
			mk_def_convert(
				func_name='_as_dict',
				ret_type=lit('OrderedDict'),
				mk_result=mk_as_dict_result,
			)
		)
	if verbose:
		print(def_as_dict, end='\n\n')
		
	_as_dict = eval_def(def_as_dict)
	_as_dict.__qualname__ = typename+'.'+_as_dict.__name__
	_as_dict.__module__ = _module_name
	Class._as_dict = _as_dict
	Class.as_dict  = _as_dict 
	Class._asdict  = _as_dict # namedtuple convention
	Class.asdict   = _as_dict


	# .__getstate__()

	mk_getstate_result = lambda selfname, id_varname, id_, variant, fields: \
		tuple_([id_varname]+['{s}._{v}_{f}'.format(s=selfname, v=variant, f=field) for field in fields])
	def_getstate = \
		flatten_tree(
			mk_def_convert(
				func_name='__getstate__',
				ret_type='tuple',
				mk_result=mk_getstate_result,
			)
		)

	if verbose:
		print(def_getstate, end='\n\n')

	__getstate__ = eval_def(def_getstate)
	__getstate__.__qualname__ = typename+'.'+__getstate__.__name__
	__getstate__.__module__ = _module_name
	Class.__getstate__ = __getstate__


	def mk_def_replace(typename, typecheck, variant_ids, variants, variant_id_fields, variant_id_types, _set_attr):
		with_fields    = [
			(id_, variant, fields, types)
			for (id_, variant, fields, types) in zip(variant_ids, variants, variant_id_fields, variant_id_types)
			if fields
		]
		without_fields = [
			(id_, variant, fields, types)
			for (id_, variant, fields, types) in zip(variant_ids, variants, variant_id_fields, variant_id_types)
			if not fields
		]

		if typecheck == 'always' or (typecheck == 'debug' and __debug__):
			set_fields = lambda variant, fields, types: \
				[tuple_(field+'_type' for field in fields)+' = cls._variant_id_types[variant_id]',
				 ''] \
				+ \
				concat(
					['new_{field} = fields_and_new_vals_pop("{field}", self._{attr})'.format(field=field, attr=(variant+'_'+field)),
					 *(['cls.assert_type(\'field "{field}"\', new_{field}, {field}_type)'.format(field=field)]
					   if type_ is not Any and type_ is not object else []
					  ),
					 _set_attr.format(obj='new', attr=(variant+'_'+field), val='new_'+field),
					 ''
					]
					 for (field, type_) in zip(fields, types)
				)
		else:
			set_fields = lambda variant, fields, _types: [
				 _set_attr.format(
				 	obj='new',
				 	attr=(variant+'_'+field),
				 	val='fields_and_new_vals_pop("{field}", self._{attr})'.format(
				 		field=field,
				 		attr=(variant+'_'+field)
				 	)
				 )
				 for field in fields
			]



		return [
			'def _replace(self, **fields_and_new_vals) -> '+lit(typename)+':', [
				'"""',
				"Analogous to `namedtuple`'s `_replace`.",
				"Returns a new value with fields modified according",
				"to the keyword arguments.",
				'"""',
				'cls = self.__class__',
				'new = cls.__new__(cls)',
				'',
				'variant_id = self._variant_id',
				_set_attr.format(obj='new', attr='variant_id', val='variant_id'),
				'',
				'# make local to avoid lookups',
				'fields_and_new_vals_pop = fields_and_new_vals.pop',
				'',
				*cond(
					# nothing to do on variants with no fields
					([when(
						join_with_op(
							['variant_id == '+lit(id_) for (id_, _, _, _) in without_fields],
							op='or', zero=False,
						),
						['if not fields_and_new_vals: return new'])
					] if without_fields else [])
					+
					# variants with fields
					[ when('variant_id == '+lit(id_), 
						set_fields(variant, fields, types)
						+
						['if not fields_and_new_vals: return new']
					  )
					  for (id_, variant, fields, types) in with_fields
					],
					default=['raise cls._get_invalid_variant_error(variant_id)'],
					allow_zero_cases=True,
				),
				'',
				# 'if not fields_and_new_vals:', [
				# 	'return new',
				# ],
				# 'else:', [
				'first_bad_field = next(iter(fields_and_new_vals))',
				'if first_bad_field.startswith("_"):', [
					"# Catch this here. if __getattr__ sees this name,", 
					"# it will (correctly) guess that it can't be a field,",
					"# and will show the generic 'object doesn't have attribute x' error",
					"# However, if someone tries to `a._replace(_variant_id=15)`, the message will",
					"# be confusing, because the objects clearly *do* have a '_variant_id' attribute.", 
					'raise TypeError("_replace() can only modify fields, and \'{}\' is not a field".format(first_bad_field))',
				],
				'else:', [
					'# getattr should give a nice error message',
					'self.__getattr__(first_bad_field)',
				],
				# ],
			],
		]

	replace_ = \
		flatten_tree(
			mk_def_replace(
				typename=typename,
				typecheck=typecheck,
				variant_ids=Class._variant_ids,
				variants=Class._variants,
				variant_id_fields=Class._variant_id_fields,
				variant_id_types=Class._variant_id_types,
				_set_attr=_set_attr,
			)
		) 
	if verbose:
		print(replace_, end='\n\n')

	_replace = eval_def(replace_)
	_replace.__qualname__ = typename+'.'+_replace.__name__
	_replace.__module__ = _module_name
	Class._replace = _replace
	Class.replace  = _replace
	Class.set      = _replace
	Class.update   = _replace


	# match

	mk_def_replace2 = lambda variant_ids, variant_id_fields, variants, all_variant_fields: [
		'def _replace(self, '+str.join(', ', (field+'=...' for field in all_variant_fields))+'):', [
			
		]
	]

	mk_def_match = lambda variant_ids, variant_id_fields, variants, unused='...': [
		'def match(_self, '+(str.join(', ', (variant+'='+unused for variant in variants)) if variants else '*') +', _=...):', [
			'_variant_id = _self._variant_id',
			*cond(
				[
					when('_variant_id == '+lit(id_)+' and '+variant+' is not '+unused, [
						'return '+apply(variant, ['_self._'+variant+'_'+field for field in fields])
					])
					for (id_, variant, fields) in zip(variant_ids, variants, variant_id_fields)
				] + \
				[	
					when('_ is not '+unused, [
						'return _()'
					])
				],
				default=[
					'raise ValueError("Pattern match incomplete - '+
						'no pattern for variant {self._variant}, and no default (`_`) provided".format(self=_self))'
				]
			)
		]
	]
	# mk_def_match = lambda variant_ids, variant_id_fields, variants, all_variant_fields, unused='...': [
	# 	'def match(_self, '+(str.join(', ', (variant+'='+unused for variant in variants)) if variants else '*') +', _=...):', [
	# 		'_case = '+tuple_(variants)+'[_self._variant_id]',
	# 		'if _case is not '+unused+':' ,[
	# 			'return _case(*_self._values())'
	# 		],
	# 		'elif _ is not '+unused+':' ,[
	# 			'return _()'
	# 		],
	# 		'else:', [
	# 			'raise ValueError("Pattern match incomplete - '
	#				 'no pattern for variant {self._variant}, and no default (`_`) provided".format(self=_self))'
	# 		]

	# 	]
	# ]

	def_match = \
		flatten_tree(
			mk_def_match(
				variant_ids=Class._variant_ids, 
				variant_id_fields=Class._variant_id_fields, 
				variants=Class._variants, 
			)
		)
	if verbose:
		print(def_match, end='\n\n')
		
	_match = eval_def(def_match)
	_match.__qualname__ = typename+'.'+_match.__name__
	_match.__module__ = _module_name
	Class._match = _match
	Class.match  = _match 

	# constructors
	def mk_def_constructor(typename, id_, variant, fields, types):
		# field_args_decl = [
		# 	(field+': '+type_literal(type_)) if type_ not in (Any, object) else field
		# 	for (field, type_) in zip(fields, types)
		# ]
		return [
			def_(variant, ['_cls', *fields]), [
				'_val = _cls.__new__(_cls)',
				# _set_attr.format(obj='_val', attr='variant_id', _val=lit(id_)),
				'_cls._unsafe_set_variant_id(_val, {id_})'.format(id_=id_),
				*(
				# _set_attr.format(obj='_val', attr=variant+'_'+field, _val=field)
				"_cls._unsafe_set_{variant}_{field}(_val, {field})".format(variant=variant, field=field)
				for field in fields
				),
				'return _val',
			],
		]

	# fast, but doesn't work with defensive setattr 
	# __set_field = "val.{real_attr} = {field_arg}"
	# slower because of the extra method lookup, but works with defensive setattr
	# __set_field = "cls.{real_attr}.__set__(val, {field_arg})"
	# ^ Uses property descriptors, because normal assignments are blocked to make the values more or less immutable


	# TODO:
	# Possible perf improvement:
	# Cache the descriptors' __set__ methods to skip one lookup.
	# This makes setting via descriptor call as fast as setting via '='. 
	# It introduces a bit of complexity though - it's another thing to
	# remember. Maybe add this after investigating Pickle integration.

	# Class.__set_variant_id = Class._variant_id.__set__
	# Class.__set_0 = Class._0.__set__
	# Class.__set_1 = Class._1.__set__

	constructors = []
	for (id_, variant) in zip(Class._variant_ids, Class._variants):
		fields = Class._variant_id_fields[id_]
		types = variant_attr_types[id_]
		fields_and_types = variant_attr_specs[id_]
		_def_constructor = \
			flatten_tree(
				mk_def_constructor(
					typename=typename,
					id_=id_,
					variant=variant,
					fields=fields,
					types=types,
				)
			)

		if verbose:
			print(_def_constructor, end='\n\n')

		assert not hasattr(Class, variant), \
			"'{}' already defined. Class dir:\n{}".format(variant, dir(Class))
		constructor = eval_def(_def_constructor)

		constructor.__qualname__ = '{}.{}'.format(typename, constructor.__name__)
		constructor.__annotations__ = {
			field: type_
			for (field, type_) in fields_and_types
			if (type_ is not Any) and (type_ is not object)
		}
		constructor.__annotations__['return'] = Class
		if fields:
			constructor = maybe_typechecked(constructor)
		constructor = classmethod(constructor)
		# constructor = functools.wraps(constructor)(typechecked(constructor))
		setattr(Class, variant, constructor)
		constructors.append(getattr(Class, variant)) # get the bound classmethod

	Class._constructors = tuple(constructors)


	# .is_Foo(), is_Bar(), etc. methods for pattern mathing 

	mk_def_is_some_variant = lambda id_, variant: [
		'def is_'+variant+'(self) -> bool:', [
			'return self._variant_id == '+lit(id_),
		]
	]

	for (id_, variant) in zip(Class._variant_ids, Class._variants):
		_def_is_some_variant = flatten_tree(mk_def_is_some_variant(id_=id_, variant=variant))
		if verbose:
			print(_def_is_some_variant, end='\n\n')
		is_some_variant = eval_def(_def_is_some_variant)
		is_some_variant.__qualname__ = typename+'.'+is_some_variant.__name__
		is_some_variant.__module__ = _module_name
		setattr(Class, 'is_'+variant, is_some_variant)
		setattr(Class, '_is_'+variant, is_some_variant)



	# field getters

	mk_def_getter = lambda field, valid_variant_ids, variants: [
		def_(field, ['self']), [
			'variant_id = self._variant_id',
			*cond(
				[ when('variant_id == '+lit(id_), [
					'return self._{variant}_{field}'.format(variant=variants[id_], field=field)
				  ])
				  for id_ in valid_variant_ids
				],
				# the AttributeError gets swallowed by the interpreter, and __getattr__ is called as a fallback
				default=['raise AttributeError()'], 
				# default for classes with no variants (unusual but possible)
				allow_zero_cases=True,
			),
		]
	]

	for field in all_variant_fields:
		valid_variant_ids = variant_ids_that_have_attr[field]
		assert len(valid_variant_ids) >= 1, \
			"Internal error creating {name}:\n" + \
			"field {field} is present in `all_variant_fields` even though no variants seem have it.\n" + \
			"Debug:\n"+\
			"variant_specs = {variant_specs}\n" + \
			"all_variant_fields = {all_variant_fields}\n" + \
			"variant_ids_that_have_attr={variant_ids_that_have_attr}\n" \
				.format(**locals())

		_def_getter = \
			flatten_tree(
				mk_def_getter(
					field=field,
					valid_variant_ids=valid_variant_ids,
					variants=Class._variants,
				)
			)

		if verbose:
			print(_def_getter, end='\n\n')

		assert not hasattr(Class, field), "'{}' already defined. Class dir:\n{}".format(field, dir(Class))
		getter = eval_def(_def_getter)
		getter.__qualname__ = '{}.{}'.format(typename, getter.__name__)
		getter.__module__ = _module_name

		setattr(Class, field, property(getter))



	# unsafe accessors

	for (id_, variant) in zip(Class._variant_ids, Class._variants):
		for field in Class._variant_fields[variant]:
			unsafe_accessor_descriptor = getattr(Class, real_attr_for_variant_id_and_field[(id_, field)])
			
			unsafe_accessor_name = '_{var}_{field}'.format(var=variant, field=field)
			setattr(Class, unsafe_accessor_name, unsafe_accessor_descriptor)
			
			# works like a classmethod
			unsafe_setter_name = '_unsafe_set'+unsafe_accessor_name
			setattr(Class, unsafe_setter_name, unsafe_accessor_descriptor.__set__)

	# works like a classmethod
	Class._unsafe_set_variant_id = Class._variant_id.__set__

	# Collect the `_0, _1, _2, ...` descriptors in one place - comes in handy sometimes 
	Class._positional_descriptors = tuple(getattr(Class, '_{}'.format(field_ix)) for field_ix in range(max_n_fields))


	# __repr__

	mk_def_repr = lambda typename, variant_ids, variants, variant_id_fields: [
		'def __repr__(self) -> str:', [
			'variant_id = self._variant_id',
			*cond(
				[ when('variant_id == '+lit(id_), [
						# reuse `apply` to build something like 'return "Foo(x={self.x})".format(self=self)'
						# because it's good for `foo(a=x, b=y)` syntax
						('return "' +
							apply(
								typename+'.'+variant,
								kwargs=[(field, '{self._'+variant+'_'+field+'!r}') for field in variant_id_fields[id_]]
							) +
							'".format(self=self)'
						)
						# + apply(variant, [(field, '{self._'+variant+'_'+field+'}') for field in fields]) \
				  ])
				  for (id_, variant) in zip(variant_ids, variants)
				],
				default=['raise self.__class__._get_invalid_variant_error(variant_id)'],
				allow_zero_cases=True,
			)
		]
	]

	_def_repr = \
		flatten_tree(
			mk_def_repr(
				typename=typename,
				variant_ids=Class._variant_ids,
				variants=Class._variants,
				variant_id_fields=Class._variant_id_fields
			)
		)

	if verbose:
		print(_def_repr, end='\n\n')


	
	__repr__ = eval_def(_def_repr)
	__repr__.__qualname__ = '{}.{}'.format(typename, __repr__.__name__)
	__repr__.__module__ = _module_name
	Class.__repr__ = __repr__


	# __eq__

	mk_def_eq = lambda variant_ids, variants, variant_id_fields: [
		'def __eq__(a, b) -> bool:', [
			'if a.__class__ is not b.__class__:', [
				'return NotImplemented',
			],
			'',
			'a_variant_id = a._variant_id',
			'b_variant_id = b._variant_id',
			'if a_variant_id != b_variant_id:', [
				'return False',
			],
			'',
			*cond(
				[ when("a_variant_id == "+lit(id_), [
						# either "return (a._0 == b._0) and (a._1 == b._1) and ...""
						# or     "return True" if a variant has no fields
						"return " + \
							join_with_op(
								('a._{variant}_{field} == b._{variant}_{field}'.format(variant=variant, field=field)
										for field in fields
								),
								op='and',
								zero='True',
							),
				  ])
				  for (id_, variant, fields) in zip(variant_ids, variants, variant_id_fields)
				],
				default=['raise a.__class__._get_invalid_variant_error(a_variant_id)'],
				allow_zero_cases=True
			)
		],
	]

	
	_def_eq = \
		flatten_tree(
			mk_def_eq(
				variant_ids=Class._variant_ids, 
				variants=Class._variants, 
				variant_id_fields=Class._variant_id_fields,
			)
		)

	if verbose:
		print(_def_eq, end='\n\n')

	__eq__ = eval_def(_def_eq)
	__eq__.__qualname__ = typename+'.'+__eq__.__name__
	__eq__.__module__ = _module_name
	Class.__eq__ = __eq__


	# __setstate__

	def mk_def_setstate(typename, variant_ids, variants, variant_id_fields, _set_attr):
		with_fields    = [
			(id_, variant, fields)
			for (id_, variant, fields) in zip(variant_ids, variants, variant_id_fields)
			if fields
		]
		without_fields = [
			(id_, variant, fields)
			for (id_, variant, fields) in zip(variant_ids, variants, variant_id_fields)
			if not fields
		]

		return [
			'def __setstate__(self, state: tuple) -> None:', [
				'cls = self.__class__',
				'variant_id = state[0]',
				_set_attr.format(obj='self', attr='variant_id', val='variant_id'),
				# 'cls._unsafe_set_variant_id(self, variant_id)',
				*cond(
					([when(
						join_with_op(
							['variant_id == '+lit(id_) for (id_, _, _) in without_fields],
							op='or', zero=False,
						),
						['return'])
					] if without_fields else [])
					+
					[ when('variant_id == '+lit(id_), [
						tuple_(['_']+['new_'+field for field in fields])+' = state'  
					  ]+[
						_set_attr.format(obj='self', attr=variant+'_'+field, val='new_'+field)
						# 'cls._unsafe_set_{variant}_{field}(self, new_{field})'\
						# 	.format(field=field, variant=variant)
						 for field in fields
						 # for (field_ix, field) in enumerate(variant_id_fields[id_])
					  ]+['return'])
					 for (id_, variant, fields) in with_fields
					],
					default=['raise cls._get_invalid_variant_error(variant_id)'],
					allow_zero_cases=True,
				),
			],
		]

	_def_setstate = \
		flatten_tree(
			mk_def_setstate(
				typename=typename,
				variant_ids=Class._variant_ids,
				variants=Class._variants,
				variant_id_fields=Class._variant_id_fields,
				_set_attr=_set_attr,
			)
		) 
	if verbose:
		print(_def_setstate, end='\n\n')
	
	__setstate__ = eval_def(_def_setstate)
	__setstate__.__qualname__ = typename+'.'+__setstate__.__name__
	__setstate__.__module__ = _module_name
	Class.__setstate__ = __setstate__

	# typename = Class.__name__
	# for name in dir(Class):
	# 	val = getattr(Class, name)
	# 	mod = getattr(val, '__module__', None)
	# 	if mod is not None and mod == __name__:
	# 		print('fixing __module__:', val, '(was:', repr(val.__module__), ')')
	# 		if not hasattr(val, '__module__'): raise RuntimeError('???')
	# 		val.__module__ = _module_name
	# 		if hasattr(val, '__qualname__'):
	# 			val.__qualname__ = typename+'.'+val.__name__
	return Class





def uniq(xs: List[A]) -> List[A]:
	""" Like set(xs), but order-preserving.""" 
	seen = set()
	res = []
	for x in xs:
		if x not in seen:
			res.append(x)
			seen.add(x)
	return res

def concat(xs: List[List[A]]) -> List[A]:
	return sum(xs, [])


UNSAFE_ACCESSORS_README = """
Thing._Foo_x   = Thing._0
Thing._Foo_y   = Thing._1
...

In contrast with the regular accessors like .x, .y, these will *NOT* check 
if they were called on the correct variant. They can be used for speed
if you know that the variant of a value.
Note, however, that they may silently return incorrect results
when used on an incorrect variant.

	>>> # class Thing = Foo(x, y, z) | Bar(a, z)
	>>>
	>>> # Correct - accessing Bar fields on a Bar value:
	>>>
	>>> # checked access - will error for variants that don't have the field
	>>> # (still very fast)
	>>> Bar(a=3, z=10).a 
	3
	>>> Bar(a=3, z=10).z
	10
	>>> # unchecked access - assumes the value is a Bar
	>>> # A bit faster, but can hide bugs 
	>>> Bar(a=3, z=10)._Bar_a
	3
	>>> # Note that even though the two variants share a field name,
	>>> # everything works correctly 
	>>> Bar(a=3, z=10)._Bar_z
	10
	>>> Foo(x=7, y=8, z=9)._Foo_z
	9
	>>>
	>>>
	>>> # Incorrect - accessing Foo fields on a Bar value
	>>>
	>>> # safe accessors will catch incorrect accesses:
	>>> Bar(a=3, z=10).x
	AttributeError(...)
	>>> Bar(a=3, z=10).y
	AttributeError(...)
	>>> # But unsafe ones won't:
	>>> Bar(a=3, z=10)._Foo_x	# assumes the value is a Foo, silently returns an incorrect result
	3
	>>> Bar(a=3, z=10)._Foo_y	# assumes the value is a Foo, silently returns an incorrect result
	10
	>>> Bar(a=3, z=10)._Foo_z 	# errors because of implementation details 
	AttributeError(...)
	>>>
	>>> # Incorrect - accessing Bar fields on a Foo value
	>>>
	>>> Foo(x=10, y=15).a 		# safe accessors will catch incorrect accesses
	AttributeError(...)
	>>> Foo(x=10, y=15)._Bar_a	# assumes the value is a Bar, silently returns an incorrect result
	10
"""









def main():
	from dis import dis

	# Void, = untyped_sumtype('Void', [], verbose=True, allow_zero_constructors=True)
	# # print(dir(Void))
	# print('\n\n')
	# Void has no constructors, so it can't be instantiated.
	# Mostly useless, but the fact that it works gives me a certain peace of mind about the codegen :)
	# (inspired by Haskell, just like this whole module)

	Thing = untyped_sumtype(
	'Thing',
	[
		('Foo', ['x', 'y',]),
		('Bar', ['y',     ]),
		('Zip', ['hey',   ]),
		('Hop', []         ),
	],
	 verbose=True,
	)

	print('__name__     : ', Thing.__name__)
	print('__qualname__ : ', Thing.__qualname__)
	print('__module__   : ', Thing.__module__)
	# print('__doc__:', Thing.__doc__, sep='\n')
	# help(Thing)
	print('_positional_descriptors:', getattr(Thing, '_positional_descriptors', None))
	# print(dir(Thing))

	# print()
	# dis_func = Thing.__setstate__
	# print('dis(%s):' % dis_func.__qualname__)
	# print()
	# dis(dis_func)
	# print()
	
	foo = Thing.Foo(3, 5)
	bar = Thing.Bar("nice")
	zip = Thing.Zip(15.234)
	hop = Thing.Hop()


	print("Attribute access:")
	all_variant_fields = uniq( sum((Thing._variant_fields[variant] for variant in Thing._variants), ()) )

	for val in ('foo', 'bar', 'zip', 'hop'):
		val_ = eval(val)
		print("\t{}".format(val_))
		for field in all_variant_fields:
			should_work = (field in Thing._variant_fields[val_.variant])
			expr = "{val}.{field}".format(**locals())
			try:
				res = eval(expr)
				did_work = True
			except AttributeError as e:
				res = e
				did_work = False

			print(
				"\t\t{should}{did} {expr:<10}: {res!r}".format(
					expr=expr, res=res,
					should={True: '+', False: '-'}[should_work],
					did={True: '+', False: '-'}[did_work]
				)
			)

			assert should_work == did_work

			# print()
		expr = '{val}.{bad}'.format(val=val, bad=str.join('', all_variant_fields))
		try: res = eval(expr)
		except AttributeError as e: res = e
		print(
			"\t{expr:<10}: {res!r}".format(
				expr=expr, res=res,
			)
		)
		print()
		print()




	print()
	print(foo, bar, zip, hop, sep='\n')
	# Thing._variant_id.__set__(foo, 5)
	print("x==x:", foo==foo, bar==bar, zip==zip, hop==hop)
	print("V(*args) == V(*args):", Thing.Foo(3,5) == Thing.Foo(3,5))
	print("V(*args1) == V(*args2):", Thing.Foo(3,5) == Thing.Foo(0,10))
	print("X(*args) == Y(*args)", Thing.Bar(3) == Thing.Zip(3))
	print()
	foo2 = foo._copy()
	print("x, x.copy(), x is x.copy():", foo, foo2, foo is foo2, sep=', ')
	bar2 = bar._copy()
	print("x, x.copy(), x is x.copy():", bar, bar2, bar is bar2, sep=', ')
	zip2 = zip._copy()
	print("x, x.copy(), x is x.copy():", zip, zip2, zip is zip2, sep=', ')
	hop2 = hop._copy()
	print("x, x.copy(), x is x.copy():", hop, hop2, hop is hop2, sep=', ')
	bar2 = bar.replace(y="better")
	print("replace:", bar, bar2)
	print("x.is_X()", foo.is_Foo(), bar.is_Bar(), zip.is_Zip())
	print("x.is_Y()", foo.is_Bar(), bar.is_Zip(), zip.is_Foo())

	try: res = bar.replace(blah_blah_blah=5)
	except Exception as e: res = e
	print("bad replace 1:", bar, repr(res))

	try: res = bar.replace(_0=5)
	except Exception as e: res = e
	print("bad replace 2:", bar, repr(res))

	try: res = bar.replace(_variant_id=5)
	except Exception as e: res = e
	print("bad replace 2:", bar, repr(res))

	foo_ = Thing.Foo(3, 5)
	try:
		Thing._variant_id.__set__(foo_, 15)
		res = repr(foo_)
	except Exception as e:
		res = e
	print("repr of bad variant:", repr(res))

	foo_ = Thing.Foo(3, 5)
	Thing._unsafe_set_Foo_x(foo_, 10)
	print('unsafe set: Foo(3, 5) ->', foo_)
	# del foo._Foo_y
	# print(foo)

	# foo._Foo_y = 10
	# print(foo)

if __name__ == '__main__':
	main()


# dynamic versions of some methods

# def __setstate__(self, state: tuple) -> None:
# 	""" For unpickling """
# 	# TODO: efficiency - codegen it
# 	cls = self.__class__
# 	_variant_id, *field_vals = state

# 	variant_id_descriptor = cls._variant_id
# 	variant_id_descriptor.__set__(self, _variant_id)

# 	field_descriptors = cls._positional_descriptors 
# 	for (field_descriptor, field_val) in zip(field_descriptors, field_vals):
# 		field_descriptor.__set__(self, field_val)


# def _values(self) -> tuple:
# 	# TODO: codegen it
# 	cls = self.__class__
# 	field_vals = (
# 		field_descriptor.__get__(self)
# 		for field_descriptor
# 		in cls._positional_descriptors[ : len(cls._variant_id_fields[self._variant_id])]
# 	)
# 	return tuple(field_vals)
# values = _values


# def _as_tuple(self) -> tuple:
# 	return (self._variant,) + self._values()
# as_tuple = _as_tuple 
# _astuple = _as_tuple # namedtuple convention
# astuple  = _as_tuple



# def _as_dict(self) -> dict:
# 	# TODO: codegen it
# 	cls = self.__class__
# 	res = {'variant': self._variant}
# 	for (field, val) in zip(cls._variant_id_fields[self._variant_id], self._values()):
# 		res[field] = val
# 	return res
# as_dict = _as_dict
# _asdict = _as_dict # namedtuple convention
# asdict  = _as_dict # namedtuple convention


# def _replace(self, **fields_and_new_vals) -> name:
# 	"""
# 	Analogous to `namedtuple`'s `_replace`.
# 	Returns a new value with fields modified according
# 	to the keyword arguments.
# 	"""
# 	cls = self.__class__
# 	fields = cls._variant_id_fields[self._variant_id]
# 	field_descriptors = cls._positional_descriptors

# 	new = cls.__new__(cls)
# 	variant_id_descriptor = cls._variant_id
# 	variant_id_descriptor.__set__(new, self._variant_id)

# 	# important - by using zip, `field_descriptors` gets trimmed to the length of `fields`,
# 	# so we never access an uninitialized attribute
# 	for (field, field_descriptor) in zip(fields, field_descriptors):
# 		old_field_val = field_descriptor.__get__(self)
# 		new_field_val = fields_and_new_vals.pop(field, old_field_val)
# 		field_descriptor.__set__(new, new_field_val)

# 	if not fields_and_new_vals:
# 		return new
# 	else:
# 		# Reuse __getattr__'s error cause guessing.
# 		# TODO: Factor it out to make it less hacky.
# 		first_bad_field = next(iter(fields_and_new_vals))
# 		if first_bad_field.startswith('_'):
# 			# Catch this here. if __getattr__ sees this name, 
# 			# it will (correctly) guess that it can't be a field,
# 			# and will show the generic "object doesn't have attribute x" error.
# 			# However, if someone tries to `a._replace(_variant_id=15)`, the message will
# 			# be confusing, because the objects clearly *do* have a '_variant_id' attribute. 
# 			raise TypeError("_replace can only modify fields, and '{}' is not a field".format(first_bad_field))
# 		else:
# 			# getattr should give a nice error message
# 			self.__getattr__(first_bad_field)
#
#
# replace = _replace
# set     = _replace
# update  = _replace