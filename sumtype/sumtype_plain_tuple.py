from typing import (
	Any,
	Tuple, List, Iterator,
	Callable,
	TypeVar,
	NoReturn, # functions that always raise or exit the interpreter 
)

Fun = Callable
A = TypeVar('A')

from indented import flatten_tree
from indented.codegen import (
	lit, apply, tuple_,
	def_, cond, when,
	join_with_op,
	eval_def,
)

from operator import itemgetter

import sys
from warnings import warn

from keyword import iskeyword


__all__ = [
	'sumtype',
	'untyped_sumtype',
]


def sumtype(
		name: str,
		variant_specs: List[  Tuple[str, List[Tuple[str, type]] ]  ],
		typecheck=False,
		immutable=True,
		verbose=False,
		_module_name=None,
	) -> type:

	if typecheck:
		raise NotImplementedError('Typechecking is not supported yet')
	if not immutable:
		raise NotImplementedError('Mutability is not supported yet')
	
	print('sumtype::', name, *variant_specs, sep='\n')
	variant_specs = [(variant_name, [attr_name for (attr_name, attr_type) in attr_names_and_types])
					 for (variant_name, attr_names_and_types) in variant_specs]

	# module name

	# `untyped_sumtype` relies on sys._getframe to inspect the caller's frame and
	# get the right module name. That won't work if `sumtype` calls it,
	# since the caller's frame will be located in this module.
	# So we have to get the module name here, and pass it down.				 
	# See the "module name" section in `sumtype`'s definition for more.
	if _module_name is None:
		try:
			_module_name = sys._getframe(1).f_globals.get('__name__', '__main__')
		except (AttributeError, ValueError):
			warn(RuntimeWarning("Cannot access the caller's module name - pickle will likely have trouble unpickling {} objects".format(name)))
			_module_name = '<generated by sumtype>'

	return untyped_sumtype(name, variant_specs, immutable=immutable, verbose=verbose, _module_name=_module_name)




def untyped_sumtype(
		name: str,
		variant_specs: List[ Tuple[str, List[str]] ],
		immutable=True,
		verbose=False,
		_module_name=None,
	) -> type:

	if not immutable:
		raise NotImplementedError('Mutability is not supported yet')

	variant_names      = [variant_name for (variant_name, attr_names_and_types) in variant_specs]
	variant_attr_names = [attr_names for (variant_name, attr_names) in variant_specs]
	variant_ids = range(len(variant_names))

	# # useful for the typed version:
	# variant_attr_specs = [attr_names_and_types for (variant_name, attr_names_and_types) in variant_specs]
	# variant_attr_names = [[attr_name for (attr_name, attr_type) in attr_names_and_types] for attr_names_and_types in variant_attr_specs]
	# # variant_attr_types = [[attr_type for (attr_name, attr_type) in attr_names_and_types] for attr_names_and_types in variant_attr_specs]

	max_n_fields = max((len(attrs) for attrs in variant_attr_names), default=0)
	if verbose:
		print('class {}'.format(name))



	class Class(tuple):
		__slots__ = ()

		_variants    = variant_names
		_variant_ids = tuple(variant_ids)
		_variant_fields = {
			name: tuple(fields)
			for (name, fields) in zip(variant_names, variant_attr_names)
		}
		_variant_id_fields = tuple(tuple(field_names) for field_names in variant_attr_names)


		def raise_direct_init_forbidden(self) -> NoReturn:
			""" Objects of this class can only be created with its constructor-classmethods. """
			cls = self.__class__
			raise TypeError(
				'Cannot instantiate {type!r} directly - use one of the variant constructors: {vars}'.format(
					type=cls.__name__, vars=cls._variants_repr()
				)
			)
		__init__ = raise_direct_init_forbidden

		# disable direct indexing and iteration
		# __getitem__ = None
		# __iter__    = None


		# cache some tuple methods - reused later

		# # not bound to the class or instance it's called on
		# _tuple_new  = staticmethod(tuple.__new__)

		# # bound to this class - Class._from_tuple(t) == tuple.__new__(Class, t)
		_from_tuple = classmethod(tuple.__new__)
		# @classmethod
		# def _from_tuple(cls, tup): return tuple.__new__(cls, tup)

		# aliases
		from_tuple  = _from_tuple
		_fromtuple  = _from_tuple # namedtuple convention

		# bound to instance
		_tuple_getitem = tuple.__getitem__
		_tuple_eq      = tuple.__eq__
		_tuple_iter    = tuple.__iter__


		_variant_id = property(itemgetter(0))
		# _allitems_getters = tuple(itemgetter(*range(len(fields)+1)) for fields in _variant_id_fields)

		@property
		def _variant(self) -> str:
			return self._variants[self._variant_id]
		variant = _variant

		# bound to the instance
		# self._as_tuple() == tuple.__new__(tuple, self)
		def _as_tuple(self): return tuple(self)
		# def _as_tuple(self): return tuple.__new__(tuple, self)
		# def _as_tuple(self): return tuple.__new__(tuple, (*self._tuple_iter(),))
		as_tuple = _as_tuple 
		_astuple = _as_tuple # namedtuple convention
		astuple  = _as_tuple

		def _values(self) -> tuple:
			return self._as_tuple()[1:]
		values = _values




		def _as_dict(self) -> dict:
			# TODO: codegen it
			res = {'variant': self._variant}
			for (field, val) in zip(self._variant_id_fields[self._variant_id], self._values()):
				res[field] = val
			return res
		as_dict = _as_dict
		_asdict = _as_dict # namedtuple convention
		asdict  = _as_dict # namedtuple convention


		def _replace(self, **fields_and_new_vals) -> name:
			"""
			Analogous to `namedtuple`'s `_replace`.
			Returns a new value with fields modified according
			to the keyword arguments.
			"""
			cls = self.__class__
			variant_id = self._variant_id
			fields = cls._variant_id_fields[variant_id]

			# make local to avoid lookups
			# self_tuple_getitem           = self._tuple_getitem
			fields_and_new_vals_pop = fields_and_new_vals.pop

			new_values = [variant_id] + [
				fields_and_new_vals_pop(field, self[field_ix])
				for (field_ix, field) in enumerate(fields, 1)
			]
			new = cls.from_tuple(new_values)

			# new_values = (
			# 	fields_and_new_vals_pop(field, self[field_ix])
			# 	# fields_and_new_vals_pop(field, self_tuple_getitem(field_ix))
			# 	for (field_ix, field) in enumerate(fields, 1)
			# )

			# new = cls.from_tuple((variant_id, *new_values))
			if not fields_and_new_vals:
				return new
			else:
				# Reuse __getattr__'s error cause guessing.
				# TODO: Factor it out to make it less hacky.
				first_bad_field = next(iter(fields_and_new_vals))
				if first_bad_field.startswith('_'):
					# Catch this here. if __getattr__ sees this name, 
					# it will (correctly) guess that it can't be a field,
					# and will show the generic "object doesn't have attribute x" error.
					# However, if someone tries to `a._replace(_variant_id=15)`, the message will
					# be confusing, because the objects clearly *do* have a '_variant_id' attribute. 
					raise TypeError("_replace can only modify fields, and '{}' is not a field".format(first_bad_field))
				else:
					# getattr should give a nice error message
					self.__getattr__(first_bad_field)


		replace = _replace
		set     = _replace
		update  = _replace



		# Methods that always raise

		def _raise_error_missing_descriptor(self, attr: str) -> NoReturn:
			"""
			A fake __getattr__ implemented only to give better error messages.
			Will always raise an exception, because if it was called, one of the
			following is true:
			- the class has no data descriptor for `attr`
			- the class has a data descriptor for `attr`, but the descriptor raised AttributeError()
				(e.g. the user tried to access an uninitialized slot)
			"""

			cls = self.__class__

			if cls._is_unsafe_accessor_name(attr):
				attr = cls._extract_field_from_unsafe_accessor_name(attr)

			ex = None
			if any(attr in fields for fields in cls._variant_fields.values()):
				# A data descriptor for 'attr' exists, but it raised AttributeError() and the interpreter called __getattr__ as a fallback
				ex = AttributeError(
					"Incorrect '{type}' variant: Field '{attr}' not declared in variant '{var}'. Variants: {vars}".format(
						attr=attr, var=self._variant, type=cls.__qualname__, vars=cls._variants_repr(),
					),
				)
			elif cls._is_permitted_sumtype_field_name(attr):
				# No data descriptor for 'attr' exists - if we didn't create it, then there's no attribute with
				# this name in any variant
				ex = AttributeError(
					"Unknown attribute: Field '{attr}' not declared in any variant of '{type}': {vars}".format(
						attr=attr, type=cls.__qualname__, vars=cls._variants_repr(),
					) 
				)
			else: # Couldn't possibly be a field - probably a typo or nonexistent method
				ex = AttributeError("'{type}' object has no attribute '{attr}'".format(type=cls.__qualname__, attr=attr,) )

			raise ex
		__getattr__ = _raise_error_missing_descriptor



		def _raise_setattr_forbidden(self, attr: str, val) -> NoReturn:
			"""
			A fake __setattr__ implemented only to give better error messages
			for attribute modification attempts.
			"""
			raise TypeError(
				"Cannot modify '{type}' values. Use `myval2 = myval.replace(attr=x)` instead. (Tried to set {self}.{field} = {val!r})".format(
					type=self.__class__.__qualname__, self=self, field=attr, val=val,
				)
			)
		__setattr__ = _raise_setattr_forbidden



		def _raise_delattr_forbidden(self, attr: str) -> NoReturn:
			"""
			A fake __delattr__ implemented only to give better error messages
			for attribute modification attempts.
			"""
			raise TypeError(
				"Cannot modify '{type}' values.".format(
					type=self.__class__.__qualname__,
				)
			)
		__delattr__ = _raise_delattr_forbidden

		
		@classmethod
		def _variant_reprs(cls) -> Iterator[str]:
			return (
				"{var}({fields})".format(var=variant, fields=str.join(', ', cls._variant_fields[variant]))
				for variant in cls._variants
			)


		# Error message helpers

		@classmethod
		def _variants_repr(cls) -> str:
			"Used to display all the variants in error messages."
			return str.join(', ', cls._variant_reprs())

		@classmethod
		def _is_unsafe_accessor_name(cls, field: str) -> bool:
			""" '_Foo_x' -> True """
			return any(field.startswith('_{}_'.format(variant)) for variant in cls._variants)


		@staticmethod
		def _is_permitted_sumtype_field_name(field: str) -> bool:
			return field.isidentifier() and not field.startswith('_') and not iskeyword(field)

		@staticmethod
		def _extract_field_from_unsafe_accessor_name(field: str) -> str:
			return field.split('_', maxsplit=2)[2]

		@classmethod
		def _get_invalid_variant_error(cls, variant_id) -> Exception:
			return RuntimeError(
				"Internal error: {id} is not a valid '{type}' variant id  (ids: {ids})".format(
					type=cls.__qualname__, id=variant_id, ids=cls._variant_ids,
				)
			)

	# end class


	# class name
	Class.__name__     = name
	Class.__qualname__ = name

	if _module_name is None:
		# caller of `sumtype` didn't pass a module name - get the caller's module name
		try:
			_module_name = sys._getframe(1).f_globals.get('__name__', '__main__')
		except (AttributeError, ValueError):
			warn(
				RuntimeWarning(
					"`untyped_sumtype` can't access the caller's module name - pickle will likely have trouble unpickling {!r} objects".format(name)
				)
			)
			_module_name = '<generated by sumtype>'
	Class.__module__ = _module_name

	variant_def_indent = ' ' * (len(name) + 1)
	Class.__doc__ = (
		'A sum type (also called a variant or tagged sumtype).\n' +
		'\n' +
		'{name} = ' + str.join(
			'\n{indent}| ', Class._variant_reprs()
		) + '\n' +
		'\n'

	).format(
		name=name,
		indent=variant_def_indent
	)


	all_variant_fields = uniq( sum(Class._variant_id_fields, ()) )
	variant_ids_that_have_attr = {
		attr: [
			id_ for id_ in Class._variant_ids
			if attr in Class._variant_id_fields[id_]
		]
		for attr in all_variant_fields
	}
	index_of_variant_id_field = {
		(id_, field): ix
		for id_ in Class._variant_ids
			for (ix, field) in enumerate(Class._variant_id_fields[id_], 1) # start from 1 - 0 is variant_id
	}

	###########
	# codegen #
	###########

	# These methods could be implented without codegen,
	# but they're more efficient this way.
	# We prefer code duplication to needless allocations -
	# For example `._values()` could just call `._as_tuple()`,
	# but at the cost of allocating a tuple and then another one without the first value.
	# A compiler could skip creating that tuple because it
	# immediately gets deconstructed or inline the code, but Python is interpreted.



	# constructors

	mk_def_constructor = lambda typename, id_, variant, fields: [
		def_(variant, ['cls', *fields])[:-1]+' -> "'+typename+'":', [ # TODO: fix this hack (def_ doesn't support annotations right now) 
			'return cls._from_tuple('+tuple_([id_, *fields])+')',
		],
	]

	constructors = []
	for (id_, variant) in zip(Class._variant_ids, Class._variants):
		fields = Class._variant_id_fields[id_]
		_def_constructor = \
			flatten_tree(
				mk_def_constructor(
					typename=name,
					id_=id_,
					variant=variant,
					fields=fields,
				)
			)

		if verbose:
			print(_def_constructor, end='\n\n')

		assert not hasattr(Class, variant), "'{}' already defined. Class dir:\n{}".format(variant, dir(Class))
		constructor = eval_def(_def_constructor)
		constructor.__qualname__ = '{}.{}'.format(name, constructor.__name__)
		setattr(Class, variant, classmethod(constructor))
		constructors.append(constructor)

	Class._constructors = tuple(constructors)



	# .is_Foo(), is_Bar(), etc. methods for pattern mathing 

	mk_def_is_some_variant = lambda id_, variant: [
		'def is_'+variant+'(self) -> bool:', [
			'return self._variant_id == '+lit(id_),
		]
	]

	for (id_, variant) in zip(Class._variant_ids, Class._variants):
		_def_is_some_variant = flatten_tree(mk_def_is_some_variant(id_=id_, variant=variant))
		if verbose:
			print(_def_is_some_variant, end='\n\n')
		is_some_variant = eval_def(_def_is_some_variant)
		is_some_variant.__qualname__ = '{}.{}'.format(name, is_some_variant.__name__)
		setattr(Class, 'is_'+variant, is_some_variant)



	# field getters

	mk_def_getter = lambda field, valid_variant_ids, index_of_variant_id_field: [
		def_(field, ['self']), [
			# 'self_tuple_getitem = self._tuple_getitem',
			'variant_id = self._variant_id',
			*cond(
				[ when('variant_id == '+lit(id_), [
					'return self._'+lit(index_of_variant_id_field[(id_, field)])
					# 'return self_tuple_getitem('+lit(index_of_variant_id_field[(id_, field)])+')'
				  ])
	              for id_ in valid_variant_ids
				],
				default=['raise AttributeError()'], # the AttributeError gets swallowed by the interpreter, and __getattr__ is called as a fallback
				allow_zero_cases=True, # default for classes with no variants (unusual but possible)
			),
		]
	]

	for field in all_variant_fields:
		valid_variant_ids = variant_ids_that_have_attr[field]
		assert len(valid_variant_ids) >= 1, \
			"Internal error creating {name}:\n" + \
			"field {field} is present in `all_variant_fields` even though no variants seem have it.\n" + \
			"Debug:\n"+\
			"variant_specs = {variant_specs}\n" + \
			"all_variant_fields = {all_variant_fields}\n" + \
			"variant_ids_that_have_attr={variant_ids_that_have_attr}\n" \
				.format(**locals())

		_def_getter = \
			flatten_tree(
				mk_def_getter(
					field=field,
					valid_variant_ids=valid_variant_ids,
					index_of_variant_id_field=index_of_variant_id_field,
				)
			)

		if verbose:
			print(_def_getter, end='\n\n')

		assert not hasattr(Class, field), "'{}' already defined. Class dir:\n{}".format(field, dir(Class))
		getter = eval_def(_def_getter)
		getter.__qualname__ = '{}.{}'.format(name, getter.__name__)

		setattr(Class, field, property(getter))


	# positional access without indexing

	positional_descriptors = []
	max_n_fields = max((len(fields) for fields in Class._variant_id_fields), default=0)
	max_n_items = max_n_fields+1 # +1 for the variant id
	for field_index in range(max_n_items): 
		accessor = itemgetter(field_index)
		accessor_name = '_{}'.format(field_index)
		# accessor.__name__ = accessor_name
		# accessor.__qualname__ = '{}.{}'.format(name, accessor.__name__)
		descriptor = property(accessor)
		positional_descriptors.append(descriptor)
		setattr(Class, accessor_name, descriptor)

	# # Collect the `_0, _1, _2, ...` descriptors in one place - comes in handy sometimes 
	Class._positional_descriptors = tuple(positional_descriptors)


	# unsafe accessors

	for (id_, variant) in zip(Class._variant_ids, Class._variants):
		for field in Class._variant_fields[variant]:
			field_index = index_of_variant_id_field[(id_, field)]
			unsafe_accessor = Class._positional_descriptors[field_index]
			# getter
			unsafe_getter_name = '_{var}_{field}'.format(var=variant, field=field)
			setattr(Class, unsafe_getter_name, unsafe_accessor)

			# # setter
			# unsafe_setter_name = '_unsafe_set'+unsafe_getter_name
			# setattr(Class, unsafe_setter_name, unsafe_accessor.__set__)







	# __repr__

	mk_def_repr = lambda typename, variant_ids, variants, variant_id_fields: [
		'def __repr__(self) -> str:', [
			'variant_id = self._variant_id',
			*cond(
				[ when('variant_id == '+lit(id_), [
						# reuse `apply` to build something like 'return "Foo(x={self.x})".format(self=self)'
						# because it's good for `foo(a=x, b=y)` syntax
						'return "' \
						+ apply(typename+'.'+variant, kwargs=[(field, '{self._'+str(field_ix)+'!r}') for (field_ix, field) in enumerate(variant_id_fields[id_], 1)]) \
						+ '"'
						+ ('.format(self=self)' if variant_id_fields[id_] else '')
						# + apply(variant, kwargs=[(field, '{self.'+field+'!r}') for field in variant_id_fields[id_]]) \
						# + '".format(self=self)'
						# + apply(variant, [(field, '{self._'+variant+'_'+field+'}') for field in fields]) \
				  ])
			 	  for (id_, variant) in zip(variant_ids, variants)
			 	],
				default=['raise self.__class__._get_invalid_variant_error(variant_id)'],
				allow_zero_cases=True,
			)
		]
	]

	_def_repr = \
		flatten_tree(
			mk_def_repr(
				typename=name,
				variant_ids=Class._variant_ids,
				variants=Class._variants,
				variant_id_fields=Class._variant_id_fields
			)
		)

	if verbose:
		print(_def_repr, end='\n\n')


	
	__repr__ = eval_def(_def_repr)
	__repr__.__qualname__ = '{}.{}'.format(name, __repr__.__name__)
	Class.__repr__ = __repr__


	# __eq__

	mk_def_eq = lambda variant_ids, variant_id_fields: [
		'def __eq__(a, b) -> bool:', [
			'if a.__class__ is not b.__class__:', [
				'return NotImplemented',
			],
			'return a._tuple_eq(b)'
		],
	]

	
	_def_eq = \
		flatten_tree(
			mk_def_eq(
				variant_ids=Class._variant_ids, 
				variant_id_fields=Class._variant_id_fields
			)
		)

	if verbose:
		print(_def_eq, end='\n\n')

	__eq__ = eval_def(_def_eq)
	__eq__.__qualname__ = '{}.{}'.format(name, __eq__.__name__)
	Class.__eq__ = __eq__


	# _replace

	mk_replace = lambda typename, variant_ids, variant_id_fields: [
		'def _replace(self, **fields_and_new_vals) -> '+lit(typename)+':', [
			'"""',
			"Analogous to `namedtuple`'s `_replace`.",
			"Returns a new value with fields modified according",
			"to the keyword arguments.",
			'"""',
			'cls = self.__class__',
			'variant_id = self._variant_id',

			'# make local to avoid lookups',
			'fields_and_new_vals_pop = fields_and_new_vals.pop',
			'',
			*cond(
				[ when('variant_id == '+lit(id_), [
					tuple_(['_', *('old_'+field for field in variant_id_fields[id_])])+' = self',
					'new = cls._from_tuple(' \
					+ tuple_([
							'variant_id',
							*('fields_and_new_vals_pop("{field}", old_{field})'.format(field=field)
							  for field in variant_id_fields[id_])
						]) \
					+')'
				 ] if variant_id_fields[id_] else ['new = self'])
				 for id_ in variant_ids
				],
				default=['raise self.__class__._get_invalid_variant_error(variant_id)'],
				allow_zero_cases=True,
			),
			'',
			'if not fields_and_new_vals:', [
				'return new',
			],
			'else:', [
				'first_bad_field = next(iter(fields_and_new_vals))',
				'if first_bad_field.startswith("_"):', [
					"# Catch this here. if __getattr__ sees this name,", 
					"# it will (correctly) guess that it can't be a field,",
					"# and will show the generic 'object doesn't have attribute x' error",
					"# However, if someone tries to `a._replace(_variant_id=15)`, the message will",
					"# be confusing, because the objects clearly *do* have a '_variant_id' attribute.", 
					'raise TypeError("_replace() can only modify fields, and \'{}\' is not a field".format(first_bad_field))',
				],
				'else:', [
					'# getattr should give a nice error message',
					'self.__getattr__(first_bad_field)',
				],
			],
		],
	]

	replace_ = flatten_tree(mk_replace(typename=name, variant_ids=Class._variant_ids, variant_id_fields=Class._variant_id_fields)) 
	if verbose:
		print(replace_, end='\n\n')

	_replace = eval_def(replace_)
	Class._replace = _replace
	Class.replace = _replace



	return Class





def uniq(xs: List[A]) -> List[A]:
	""" Like set(xs), but order-preserving.""" 
	seen = set()
	res = []
	for x in xs:
		if x not in seen:
			res.append(x)
			seen.add(x)
	return res




UNSAFE_ACCESSORS_README = """
Thing._Foo_x   = Thing._0
Thing._Foo_y   = Thing._1
...

In contrast with the regular accessors like .x, .y, these will *NOT* check 
if they were called on the correct variant. They can be used for speed
if you know that the variant of a value.
Note, however, that they may silently return incorrect results
when used on an incorrect variant.

	>>> # class Thing = Foo(x, y, z) | Bar(a, z)
	>>>
	>>> # Correct - accessing Bar fields on a Bar value:
	>>>
	>>> # checked access - will error for variants that don't have the field
	>>> # (still very fast)
	>>> Bar(a=3, z=10).a 
	3
	>>> Bar(a=3, z=10).z
	10
	>>> # unchecked access - assumes the value is a Bar
	>>> # A bit faster, but can hide bugs 
	>>> Bar(a=3, z=10)._Bar_a
	3
	>>> # Note that even though the two variants share a field name,
	>>> # everything works correctly 
	>>> Bar(a=3, z=10)._Bar_z
	10
	>>> Foo(x=7, y=8, z=9)._Foo_z
	9
	>>>
	>>>
	>>> # Incorrect - accessing Foo fields on a Bar value
	>>>
	>>> # safe accessors will catch incorrect accesses:
	>>> Bar(a=3, z=10).x
	AttributeError(...)
	>>> Bar(a=3, z=10).y
	AttributeError(...)
	>>> # But unsafe ones won't:
	>>> Bar(a=3, z=10)._Foo_x	# assumes the value is a Foo, silently returns an incorrect result
	3
	>>> Bar(a=3, z=10)._Foo_y	# assumes the value is a Foo, silently returns an incorrect result
	10
	>>> Bar(a=3, z=10)._Foo_z 	# errors because of implementation details 
	AttributeError(...)
	>>>
	>>> # Incorrect - accessing Bar fields on a Foo value
	>>>
	>>> Foo(x=10, y=15).a 		# safe accessors will catch incorrect accesses
	AttributeError(...)
	>>> Foo(x=10, y=15)._Bar_a	# assumes the value is a Bar, silently returns an incorrect result
	10
"""




def main():
	Void, = untyped_sumtype('Void', [], verbose=True)
	print(dir(Void))
	print('\n\n')
	# Void has no constructors, so it can't be instantiated.
	# Mostly useless, but the fact that it works gives me a certain peace of mind about the codegen :)
	# (inspired by Haskell, just like this whole module)

	(Thing,
		Foo,
		Bar,
		Zip,
		Hop) = untyped_sumtype(
	'Thing',
	[
		('Foo', ['x', 'y',]),
		('Bar', ['y',     ]),
		('Zip', ['hey',   ]),
		('Hop', []         ),
	],
	 verbose=True,
	)

	print('__name__    : ', Thing.__name__)
	print('__qualname__: ', Thing.__qualname__)
	print('__module__  : ', Thing.__module__)
	# print('__doc__:', Thing.__doc__, sep='\n')
	# help(Thing)
	print('_positional_descriptors:', [(descr.fget if isinstance(descr, property) else descr) for descr in getattr(Thing, '_positional_descriptors', None)])
	print(dir(Thing))
	
	foo = Thing.Foo(3, 5)
	bar = Thing.Bar("nice")
	zip = Thing.Zip(15.234)
	hop = Thing.Hop()


	print("Attribute access:")
	all_variant_fields = uniq( sum((Thing._variant_fields[variant] for variant in Thing._variants), ()) )

	for val in ('foo', 'bar', 'zip', 'hop'):
		val_ = eval(val)
		print("\t{}: {!r}".format(val, val_.as_tuple()), end='')
		print("{!r}".format(val_))
		for field in all_variant_fields:
			should_work = (field in Thing._variant_fields[val_.variant])
			expr = "{val}.{field}".format(**locals())
			try:
				res = eval(expr)
				did_work = True
			except AttributeError as e:
				res = e
				did_work = False

			print(
				"\t\t{should}{did} {expr:<10}: {res!r}".format(
					expr=expr, res=res,
					should={True: '+', False: '-'}[should_work],
					did={True: '+', False: '-'}[did_work]
				)
			)

			assert should_work == did_work

			# print()
		expr = '{val}.{bad}'.format(val=val, bad=str.join('', all_variant_fields))
		try: res = eval(expr)
		except AttributeError as e: res = e
		print(
			"\t{expr:<10}: {res!r}".format(
				expr=expr, res=res,
			)
		)
		print()
		print()




	print()
	print(foo, bar, zip, hop, sep='\n')
	# Thing._variant_id.__set__(foo, 5)
	print("x==x:", foo==foo, bar==bar, zip==zip, hop==hop)
	print("V(*args) == V(*args):", Thing.Foo(3,5) == Thing.Foo(3,5))
	print("V(*args1) == V(*args2):", Thing.Foo(3,5) == Thing.Foo(0,10))
	print("X(*args) == Y(*args)", Thing.Bar(3) == Thing.Zip(3))
	print()
	# foo2 = foo._copy()
	# print("x, x.copy(), x is x.copy():", foo, foo2, foo is foo2, sep=', ')
	# bar2 = bar._copy()
	# print("x, x.copy(), x is x.copy():", bar, bar2, bar is bar2, sep=', ')
	# zip2 = zip._copy()
	# print("x, x.copy(), x is x.copy():", zip, zip2, zip is zip2, sep=', ')
	# hop2 = hop._copy()
	# print("x, x.copy(), x is x.copy():", hop, hop2, hop is hop2, sep=', ')
	bar2 = bar.replace(y="better")
	expected = Bar(y='better')
	print("replace:", bar, bar2, expected)
	assert bar2 == expected

	print("x.is_X()", foo.is_Foo(), bar.is_Bar(), zip.is_Zip())
	print("x.is_Y()", foo.is_Bar(), bar.is_Zip(), zip.is_Foo())

	try: res = bar.replace(blah_blah_blah=5)
	except Exception as e: res = e
	print("bad replace 1:", bar, repr(res))

	try: res = bar.replace(_0=5)
	except Exception as e: res = e
	print("bad replace 2:", bar, repr(res))

	try: res = bar.replace(_variant_id=5)
	except Exception as e: res = e
	print("bad replace 2:", bar, repr(res))

	foo_ = Foo(3, 5)
	try:
		Thing._variant_id.__set__(foo_, 15)
		res = repr(foo_)
	except Exception as e:
		res = e
	print("repr of bad variant:", repr(res))

	assert foo.as_tuple() == (foo._0, foo._1, foo._2), repr((foo._as_tuple, foo.as_tuple(), (foo._0, foo._1, foo._2) )) 
	assert foo.x == foo._Foo_x
	assert foo.y == foo._Foo_y

	# del foo._Foo_y
	# print(foo)

	# foo._Foo_y = 10
	# print(foo)

	# Profiling

	import timeit
	from sumtype_slots import untyped_sumtype as untyped_sumtype_slots

	Thing2, *_ \
	= untyped_sumtype_slots(
	'Thing2', [
		('Foo', ('x', 'y',)),
		('Bar', ('y',)),
		('Zip', ('hey',)),
		('Hop', []),
	],
	immutable=False,
	)


	create_3_variants = """
foo = Thing.Foo(3, 5)
bar = Thing.Bar("nice")
zip = Thing.Zip(15.234)
"""
	create_3_variants_kwargs = """
foo = Thing.Foo(x=3, y=5)
bar = Thing.Bar(y="nice")
zip = Thing.Zip(hey=15.234)
"""

	access_attributes = """
x = foo.x
# y = foo.y
# y = bar.y
# z = zip.hey
"""
	unsafe_access_attributes = """
x = foo._Foo_x
# y = foo._Foo_y
# y = bar._Bar_y
# z = zip._Zip_hey
"""

	replace_all_attributes = """
foo2 = foo.replace(x=4)
# foo2 = foo.replace(x=4, y=6)
# bar2 = bar.replace(y="nicer")
# zip2 = zip.replace(hey=3.141592)
"""

	copy = """
foo2 = foo._copy()
# bar2 = bar._copy()
# zip2 = zip._copy()
"""
	# make the classes accessible to timeit
	# (they're created within `main()`, so they're not visible otherwise)
	globals()['Thing']  = Thing
	globals()['Thing2'] = Thing2

	slot_sumtype_setup  = "from __main__ import Thing2 as Thing"
	tuple_sumtype_setup = "from __main__ import Thing"


	n_timing_repetitions = 100001

	tests = (
		('slot_sumtype_create_3',          create_3_variants,        slot_sumtype_setup),
		('tuple_sumtype_create_3',         create_3_variants,        tuple_sumtype_setup),

		# ('slot_sumtype_create_3_kwargs',   create_3_variants_kwargs, slot_sumtype_setup),
		# ('tuple_sumtype_create_3_kwargs',  create_3_variants_kwargs, tuple_sumtype_setup),

		('slot_sumtype_access_all',        access_attributes,        slot_sumtype_setup +create_3_variants),
		('tuple_sumtype_access_all',       access_attributes,        tuple_sumtype_setup+create_3_variants),
		('slot_sumtype_unsafe_access_all',  unsafe_access_attributes, slot_sumtype_setup +create_3_variants),
		('tuple_sumtype_unsafe_access_all', unsafe_access_attributes, tuple_sumtype_setup+create_3_variants),

		# ('slot_sumtype_copy',              copy,                     slot_sumtype_setup +create_3_variants),
		# ('tuple_sumtype_copy',             copy,                     slot_sumtype_setup +create_3_variants),

		('slot_sumtype_replace_all_attributes',          replace_all_attributes,        slot_sumtype_setup +create_3_variants),
		('tuple_sumtype_replace_all_attributes',         replace_all_attributes,        tuple_sumtype_setup+create_3_variants),
	)
	print("Profiling")
	for (name, code, setup) in tests:
		time_usec = timeit.timeit(
			code,
			setup=setup,
			number=n_timing_repetitions
		) * 1000000 / n_timing_repetitions
		print('\t{name}:\t{time_usec:.2f} usec'.format(**locals()))

if __name__ == '__main__':
	main()


